<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unityæ€§èƒ½åˆ†æç«ç„°å›¾å·¥å…·</title>
    <style>
        /* æ•´åˆçš„å®Œæ•´CSSæ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 20px;
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1976D2;
        }

        .btn-generate {
            background-color: #4CAF50;
            color: white;
            width: 100%;
            margin-top: 20px;
        }

        .btn-generate:hover {
            background-color: #45a049;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background-color: #e8f5e8;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #2e7d32;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #4CAF50;
        }

        .file-input-container {
            position: relative;
            margin-bottom: 16px;
        }

        .file-label {
            display: block;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-label:hover {
            background-color: #45a049;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .import-info {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 10px;
        }

        .stats {
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .stat-item .label {
            font-size: 12px;
            color: #555;
            flex: 1;
        }

        .stat-item input {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            text-align: center;
        }

        .checkboxes {
            margin-bottom: 15px;
        }

        .checkboxes label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .checkboxes input[type="checkbox"] {
            margin-right: 8px;
        }

        .dropdown {
            margin-bottom: 15px;
        }

        .dropdown label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #555;
        }

        .dropdown select {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: white;
        }

        .stats-display {
            background-color: #f0f8f0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stat-row:last-child {
            margin-bottom: 0;
        }

        .stat-row .label {
            color: #555;
        }

        .function-details {
            background-color: #f0f8f0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
        }

        .detail-item {
            margin-bottom: 15px;
        }

        .detail-label {
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .detail-stats {
            font-size: 12px;
            color: #555;
        }

        .detail-stats div {
            margin-bottom: 4px;
        }

        .time-value {
            color: #ff6b35;
            font-weight: bold;
        }

        .percentage {
            color: #4CAF50;
            font-weight: bold;
        }

        .call-count, .child-count {
            color: #2196F3;
            font-weight: bold;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        .search-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .search-bar input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .breadcrumb {
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
            background-color: #f9f9f9;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .breadcrumb span {
            color: #2196F3;
            cursor: pointer;
        }

        .breadcrumb span:hover {
            text-decoration: underline;
        }

        .flame-graph-container {
            flex: 1;
            position: relative;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        #flameGraph {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .color-box {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            border: 1px solid #ddd;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 300px;
            }
            
            .main-content {
                min-height: 400px;
            }
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* åŠ¨ç”»æ•ˆæœ */
        .section {
            transition: all 0.3s ease;
        }

        .section:hover {
            transform: translateY(-1px);
        }

        .btn {
            transition: all 0.2s ease;
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* åŸæœ‰æ ·å¼ç»§ç»­ä¿æŒ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2d5a27, #4a7c59);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .header .subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .main-layout {
            display: flex;
            height: calc(100vh - 70px);
        }

        .sidebar {
            width: 300px;
            background: #2a2a2a;
            border-right: 1px solid #444;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar-section {
            border-bottom: 1px solid #444;
            padding: 15px;
        }

        .sidebar-section h3 {
            color: #4a7c59;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .data-import {
            background: #333;
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 10px;
        }

        .file-input {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .json-paste {
            margin-top: 10px;
        }

        .json-textarea {
            width: 100%;
            height: 80px;
            padding: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .btn {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #5a8c69;
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .display-settings {
            background: #2a2a2a;
        }

        /* éœ€è¦æ°´å¹³å¸ƒå±€çš„ä¸¤é¡¹å®¹å™¨ */
        .horizontal-items {
            display: flex; /* å¯ç”¨flexå¸ƒå±€ */
            gap: 10px;    /* é¡¹ä¹‹é—´çš„é—´è· */
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            font-size: 12px;
            color: #999;
        }

        .checkbox-group {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .color-scheme-select {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .color-scheme-select option {
            background: #444;
            color: #e0e0e0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4a7c59;
        }

        .stat-label {
            font-size: 12px;
            color: #999;
            margin-top: 2px;
        }

        .function-details {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            border: 1px solid #444;
        }

        .function-details .detail-header {
            color: #4a7c59;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }

        .function-details .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
        }

        .function-details .detail-label {
            color: #ccc;
            font-weight: 500;
        }

        .function-details .detail-value {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
        }

        .function-details .detail-value.highlight {
            color: #4a7c59;
            font-weight: bold;
        }

        .function-details .detail-value.warning {
            color: #f39c12;
        }

        .function-details .detail-value.danger {
            color: #e74c3c;
        }

        .function-details .performance-bar {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .function-details .performance-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a7c59, #f39c12, #e74c3c);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
        }

        .breadcrumb {
            background: #2a2a2a;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            font-size: 14px;
            white-space: nowrap;
            overflow-x: auto;
        }

        .breadcrumb-item {
            color: #4a7c59;
            cursor: pointer;
            text-decoration: none;
        }

        .breadcrumb-item:hover {
            text-decoration: underline;
        }

        .breadcrumb-separator {
            margin: 0 8px;
            color: #666;
        }

        .toolbar {
            background: #2a2a2a;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .search-box {
            flex: 1;
            max-width: 300px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 8px 35px 8px 12px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 16px;
        }

        .flame-graph-container {
            flex: 1;
            position: relative;
            overflow-x: hidden;
            overflow-y: auto;
            background: #1a1a1a;
        }
        
        .flame-graph-container::-webkit-scrollbar {
            width: 12px;
        }
        
        .flame-graph-container::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        
        .flame-graph-container::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 6px;
        }
        
        .flame-graph-container::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        .flame-graph {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .flame-box {
            position: absolute;
            border: 1px solid rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 11px;
            color: #000;
            font-weight: 500;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            padding: 2px 4px;
            box-sizing: border-box;
            transition: all 0.15s ease;
            border-radius: 2px;
            text-shadow: 0 1px 0 rgba(255,255,255,0.3);
        }

        .flame-box:hover {
            border-color: rgba(0,0,0,0.6);
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transform: translateY(-1px);
            filter: brightness(1.1);
        }

        .flame-box.selected {
            border: 2px solid #2c5aa0;
            z-index: 101;
            box-shadow: 0 0 0 1px rgba(44, 90, 160, 0.3);
        }

        .flame-box.highlighted {
            border: 2px solid #e74c3c;
            z-index: 102;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3);
        }

        @keyframes pulse {
            0%, 100% { 
                box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3), 0 0 10px rgba(231, 76, 60, 0.2); 
            }
            50% { 
                box-shadow: 0 0 0 4px rgba(231, 76, 60, 0.5), 0 0 20px rgba(231, 76, 60, 0.4); 
            }
        }



        .status-bar {
            background: #2a2a2a;
            padding: 8px 15px;
            border-top: 1px solid #444;
            font-size: 12px;
            color: #999;
        }

        .tooltip {
            position: absolute;
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid #666;
            border-radius: 4px;
            padding: 8px;
            font-size: 12px;
            color: #e0e0e0;
            pointer-events: none;
            z-index: 1001;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: #4a7c59;
        }

        .tooltip-info {
            line-height: 1.4;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 16px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        ::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>Unityæ€§èƒ½åˆ†æå·¥å…·</h1>
            <div class="subtitle">å‡½æ•°è°ƒç”¨æ—¶åºç«ç„°å›¾</div>
        </div>
    </div>

    <div class="main-layout">
        <div class="sidebar">
            <div class="sidebar-section data-import">
                <h3>æ•°æ®å¯¼å…¥</h3>
                <div class="file-input-container">
                    <input type="file" id="fileInput" accept=".json" style="display: none;" />
                    <label for="fileInput" class="file-input-button">é€‰æ‹©JSONæ–‡ä»¶</label>
                </div>
                <div class="json-paste">
                    <textarea id="jsonTextarea" class="json-textarea" placeholder="æˆ–ç²˜è´´JSONæ•°æ®..."></textarea>
                </div>
                <button id="parseJsonBtn" class="btn">æ·»åŠ JSONæ•°æ®</button>
                <div class="horizontal-items">
                    <button id="loadSampleBtn" class="btn">æ·»åŠ ç¤ºä¾‹æ•°æ®</button>
                </div>
                
                <!-- æ•°æ®èšåˆåŠŸèƒ½ -->
                <div class="data-aggregation-section" style="margin-top: 15px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #4a7c59;">ğŸ”„ æ•°æ®èšåˆ</h4>
                    <div class="aggregation-controls">
                        <button id="flipDataBtn" class="btn btn-secondary" style="width: 100%; margin-bottom: 8px;">æ•°æ®å€’è½¬</button>
                        <div class="aggregation-info" style="font-size: 11px; color: #888; padding: 8px; background: #f9f9f9; border-radius: 3px; display: none;">
                            <div id="aggregationResult">ç­‰å¾…èšåˆæ“ä½œ...</div>
                        </div>
                    </div>
                </div>

                <!-- æ•°æ®æ–‡ä»¶åˆ—è¡¨ -->
                <div class="data-list-section" style="margin-top: 15px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #4a7c59;">ğŸ“ æ•°æ®æ–‡ä»¶åˆ—è¡¨</h4>
                    <div class="data-selector">
                        <label style="font-size: 12px; color: #ccc; margin-bottom: 5px; display: block;">æ•°æ®åˆ—è¡¨ First:</label>
                        <select id="dataFirstSelect" class="data-select" style="width: 100%; margin-bottom: 10px; padding: 5px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 3px;">
                            <option value="">è¯·é€‰æ‹©æ•°æ®...</option>
                        </select>
                        
                        <label style="font-size: 12px; color: #ccc; margin-bottom: 5px; display: block;">æ•°æ®åˆ—è¡¨ Second (å¯é€‰):</label>
                        <select id="dataSecondSelect" class="data-select" style="width: 100%; margin-bottom: 10px; padding: 5px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 3px;">
                            <option value="">æ— å¯¹æ¯”æ•°æ®</option>
                        </select>
                    </div>
                    
                    <!-- æ•°æ®æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º -->
                    <div id="dataFileList" class="data-file-list" style="max-height: 120px; overflow-y: auto; border: 1px solid #444; border-radius: 3px; background: #1a1a1a;">
                        <div style="padding: 10px; text-align: center; color: #666; font-size: 12px;">æš‚æ— æ•°æ®æ–‡ä»¶</div>
                    </div>
                    
                    <!-- Diffå›¾ä¾‹ -->
                    <div id="diffLegend" class="diff-legend" style="margin-top: 10px; font-size: 11px; display: none;">
                        <div class="horizontal-items">
                            <div style="color: #e74c3c; margin-bottom: 2px;">ğŸ”´ æ€§èƒ½ä¸‹é™</div>
                            <div style="color: #27ae60; margin-bottom: 2px;">ğŸŸ¢ æ€§èƒ½æå‡</div>
                            <div style="color: #f39c12; margin-bottom: 2px;">ğŸŸ  æ–°å¢å‡½æ•°</div>
                            <div style="color: #8e44ad; margin-bottom: 2px;">ğŸŸ£ åˆ é™¤å‡½æ•°</div>
                            <div style="color: #95a5a6;">âšª æ— æ˜æ˜¾å˜åŒ–</div>
                        </div>
                    </div>
                </div>
            </div>            

            <div class="sidebar-section">
                <h3>æ€§èƒ½åˆ†æ</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalTime">0</div>
                        <div class="stat-label">æ€»æ‰§è¡Œæ—¶é—´(ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="hottestFunction">-</div>
                        <div class="stat-label">æ€§èƒ½çƒ­ç‚¹</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="slowFunctions">0</div>
                        <div class="stat-label">æ…¢å‡½æ•°(>10ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="performanceScore">0</div>
                        <div class="stat-label">æ€§èƒ½è¯„åˆ†</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxDepth">0</div>
                        <div class="stat-label">è°ƒç”¨æ·±åº¦</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="systemCallRatio">0%</div>
                        <div class="stat-label">ç³»ç»Ÿè°ƒç”¨å æ¯”</div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>å‡½æ•°è¯¦æƒ…</h3>
                <div id="functionDetails" class="function-details">
                    ç‚¹å‡»ç«ç„°å›¾ä¸­çš„å‡½æ•°å—æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
                </div>
            </div>

            
            <div class="sidebar-section display-settings">
                <h3>æ˜¾ç¤ºè®¾ç½®</h3>
                <div class="setting-item">
                    <label>æ—¶é—´é˜ˆå€¼ (ms)</label>
                    <input type="range" id="thresholdSlider" class="slider" min="0" max="10" step="0.1" value="0.1">
                    <div class="slider-value" id="thresholdValue">0.1</div>
                </div>
                <div class="setting-item">
                    <label>è¡Œé«˜ (px)</label>
                    <input type="range" id="rowHeightSlider" class="slider" min="15" max="40" step="1" value="24">
                    <div class="slider-value" id="rowHeightValue">24</div>
                </div>
                <div class="setting-item">
                    <label>æœ€å°å®½åº¦ (px)</label>
                    <input type="range" id="minWidthSlider" class="slider" min="1" max="20" step="1" value="3">
                    <div class="slider-value" id="minWidthValue">3</div>
                </div>                
            </div>
        </div>

        <div class="content-area">
            <div id="breadcrumb" class="breadcrumb">
                <a href="#" class="breadcrumb-item" data-node-id="root">æ ¹èŠ‚ç‚¹</a>
            </div>

            <div class="toolbar">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input" placeholder="æœç´¢å‡½æ•°å...">
                    <button id="searchClear" class="search-clear">Ã—</button>
                </div>
                <button id="resetViewBtn" class="btn">é‡ç½®è§†å›¾</button>
                <button id="fitViewBtn" class="btn">é€‚åº”è§†å›¾</button>
                <button id="exportBtn" class="btn">å¯¼å‡ºå›¾ç‰‡</button>
                <button id="downloadDataBtn" class="btn">ä¸‹è½½æ•°æ®</button>

                <div class="setting-item">
                    <label>é…è‰²æ–¹æ¡ˆ</label>
                    <select id="colorSchemeSelect" class="color-scheme-select">
                        <option value="performance">æ€§èƒ½å¯¼å‘</option>
                        <option value="rainbow">å½©è™¹è‰²è°±</option>
                        <option value="warm">æš–è‰²è°ƒ</option>
                        <option value="cool">å†·è‰²è°ƒ</option>
                        <option value="monochrome">å•è‰²è°ƒ</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>æ˜¾ç¤ºé€‰é¡¹</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="showSystemCalls" checked>
                            <label for="showSystemCalls">æ˜¾ç¤ºç³»ç»Ÿè°ƒç”¨</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showUserCode" checked>
                            <label for="showUserCode">æ˜¾ç¤ºç”¨æˆ·ä»£ç </label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showTooltips" checked>
                            <label for="showTooltips">æ˜¾ç¤ºå·¥å…·æç¤º</label>
                        </div>
                    </div>
                </div>

            </div>

            <div id="flameGraphContainer" class="flame-graph-container">
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">ğŸ“Š</div>
                    <div>è¯·å¯¼å…¥JSONæ•°æ®æ–‡ä»¶æˆ–åŠ è½½ç¤ºä¾‹æ•°æ®å¼€å§‹åˆ†æ</div>
                </div>
                <div id="flameGraph" class="flame-graph"></div>            
            </div>

            <div class="status-bar">
                <span id="statusText">å°±ç»ª</span>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip" style="display: none;">
        <div class="tooltip-title"></div>
        <div class="tooltip-info"></div>
    </div>

    <script>
        // FlameGraphç±» - æ•´åˆè‡ªflame-graph.js
        class FlameGraph {
            constructor(container, options = {}) {
                this.container = container;
                this.canvas = null;
                this.ctx = null;
                this.data = null;
                this.nodeMap = new Map();
                this.maxDepth = 0;
                this.selectedNode = null;
                this.focusedNode = null;
                this.highlightedFunction = null;

                this.panOffset = { x: 0, y: 0 };
                this.isDragging = false;
                this.mouseDownPos = { x: 0, y: 0 };
                this.mouseDownTime = 0;
                this.lastMousePos = { x: 0, y: 0 };
                this.lastClickTime = 0;
                this.diffData = null;
                this.isDiffMode = false;
                this.diffNodeMap = new Map();
                
                // é…ç½®é€‰é¡¹
                this.config = {
                    rowHeight: options.rowHeight || 20,
                    minWidth: options.minWidth || 1,
                    threshold: options.threshold || 0.1,
                    colorScheme: options.colorScheme || 'default',
                    showLabels: options.showLabels !== false,
                    showTooltip: options.showTooltip !== false,
                    ...options
                };
                
                // é¢œè‰²æ–¹æ¡ˆ
                this.colorSchemes = {
                    default: {
                        normal: ['#ff6b35', '#f7931e', '#ffd23f', '#06ffa5', '#1fb3d3', '#5d4e75'],
                        hot: '#ff4444',
                        cold: '#4444ff',
                        neutral: '#888888'
                    },
                    warm: {
                        normal: ['#ff9999', '#ffcc99', '#ffff99', '#ccff99', '#99ffcc', '#99ccff'],
                        hot: '#ff6666',
                        cold: '#6666ff',
                        neutral: '#999999'
                    },
                    cool: {
                        normal: ['#99ccff', '#99ffcc', '#ccff99', '#ffff99', '#ffcc99', '#ff9999'],
                        hot: '#6666ff',
                        cold: '#ff6666',
                        neutral: '#999999'
                    }
                };
                
                this.init();
            }
            
            init() {
                this.createCanvas();
                this.bindEvents();
            }
            
            createCanvas() {
                this.canvas = document.createElement('canvas');
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.cursor = 'crosshair';
                this.container.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                this.resize();
            }
            
            bindEvents() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.onWheel.bind(this));
                this.canvas.addEventListener('dblclick', this.onDoubleClick.bind(this));
                
                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', this.resize.bind(this));
            }
            
            resize() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.render();
            }
            
            setData(data) {
                this.data = data;
                this.processData();
                this.render();
            }
            
            processData() {
                if (!this.data) return;
                
                this.nodeMap.clear();
                this.maxDepth = 0;
                this.processNode(this.data, 0, 0, this.data.duration || this.data.value || 0);
            }
            
            processNode(node, depth, startTime, totalTime) {
                const duration = node.duration || node.value || 0;
                const selfTime = node.selfTime || duration;

                node.id = node.id || `${node.name}_${depth}`;
                node.depth = depth;
                node.startTime = startTime;
                node.duration = duration;
                node.selfTime = selfTime;
                node.percentage = totalTime > 0 ? (duration / totalTime) * 100 : 0;
                
                this.nodeMap.set(node.id, node);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                if (node.children && node.children.length > 0) {
                    // å¦‚æœåªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œå±…ä¸­æ”¾ç½®
                    if (node.children.length === 1) {
                        const child = node.children[0];
                        const childDuration = child.duration || child.value || 0;
                        const centerStart = startTime + (duration - childDuration) / 2;
                        this.processNode(child, depth + 1, centerStart, totalTime);
                    } else {
                        // å¤šä¸ªå­èŠ‚ç‚¹æŒ‰é¡ºåºæ’åˆ—
                        let childStartTime = startTime;
                        node.children.forEach(child => {
                            const childDuration = child.duration || child.value || 0;
                            this.processNode(child, depth + 1, childStartTime, totalTime);
                            childStartTime += childDuration;
                        });
                    }
                }
            }
            
            render() {
                if (!this.canvas || !this.data) return;
                
                const rect = this.container.getBoundingClientRect();
                this.ctx.clearRect(0, 0, rect.width, rect.height);
                
                this.renderNode(this.data, 0, 0, rect.width, this.data.duration || this.data.value || 0);
            }
            
            renderNode(node, x, y, width, totalTime) {
                const duration = node.duration || node.value || 0;
                const nodeWidth = (duration / totalTime) * width;
                const nodeHeight = this.config.rowHeight;
                
                if (nodeWidth < this.config.minWidth) return;
                
                // è®¡ç®—é¢œè‰²
                const color = this.getNodeColor(node);
                
                // ç»˜åˆ¶èŠ‚ç‚¹
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, nodeWidth, nodeHeight);
                
                // ç»˜åˆ¶è¾¹æ¡†
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 0.5;
                this.ctx.strokeRect(x, y, nodeWidth, nodeHeight);
                
                // ç»˜åˆ¶æ–‡æœ¬
                if (this.config.showLabels && nodeWidth > 50) {
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'middle';
                    
                    const text = this.truncateText(node.name || 'Unknown', nodeWidth - 4);
                    this.ctx.fillText(text, x + 2, y + nodeHeight / 2);
                }
                
                // é€’å½’ç»˜åˆ¶å­èŠ‚ç‚¹
                if (node.children && node.children.length > 0) {
                    let childX = x;
                    node.children.forEach(child => {
                        const childDuration = child.duration || child.value || 0;
                        const childWidth = (childDuration / totalTime) * width;
                        this.renderNode(child, childX, y + nodeHeight, childWidth, totalTime);
                        childX += childWidth;
                    });
                }
            }
            
            getNodeColor(node) {
                const colors = this.colorSchemes[this.config.colorScheme].normal;
                const hash = this.hashString(node.name || 'Unknown');
                return colors[hash % colors.length];
            }
            
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            truncateText(text, maxWidth) {
                const metrics = this.ctx.measureText(text);
                if (metrics.width <= maxWidth) return text;
                
                let truncated = text;
                while (this.ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                    truncated = truncated.slice(0, -1);
                }
                return truncated + '...';
            }
            
            onMouseDown(event) {
                this.isDragging = true;
                this.mouseDownPos = { x: event.clientX, y: event.clientY };
                this.mouseDownTime = Date.now();
                this.canvas.style.cursor = 'grabbing';
            }
            
            onMouseMove(event) {
                if (this.isDragging) {
                    const deltaX = event.clientX - this.lastMousePos.x;
                    const deltaY = event.clientY - this.lastMousePos.y;
                    this.panOffset.x += deltaX;
                    this.panOffset.y += deltaY;
                    this.render();
                }
                
                this.lastMousePos = { x: event.clientX, y: event.clientY };
                
                // æ˜¾ç¤ºå·¥å…·æç¤º
                if (this.config.showTooltip) {
                    this.showTooltip(event);
                }
            }
            
            onMouseUp(event) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'crosshair';
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¹å‡»è€Œä¸æ˜¯æ‹–æ‹½
                    const timeDiff = Date.now() - this.mouseDownTime;
                    const distance = Math.sqrt(
                        Math.pow(event.clientX - this.mouseDownPos.x, 2) +
                        Math.pow(event.clientY - this.mouseDownPos.y, 2)
                    );
                    
                    if (timeDiff < 300 && distance < 5) {
                        this.onClick(event);
                    }
                }
            }
            
            // onWheel(event) {
            //     event.preventDefault();
            //     const delta = event.deltaY > 0 ? 0.9 : 1.1;
            //     this.zoomLevel *= delta;
            //     this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
            //     this.render();
            // }
            
            onDoubleClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const clickedNode = this.getNodeAtPosition(x, y);
                if (clickedNode) {
                    this.selectNode(clickedNode);
                    // å¯ä»¥æ·»åŠ åŒå‡»ç‰¹æ®Šå¤„ç†ï¼Œæ¯”å¦‚èšç„¦åˆ°èŠ‚ç‚¹
                    console.log('åŒå‡»é€‰ä¸­èŠ‚ç‚¹:', clickedNode.name);
                }
            }
            
            onClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const clickedNode = this.getNodeAtPosition(x, y);
                if (clickedNode) {
                    this.selectNode(clickedNode);
                }
            }
            
            getNodeAtPosition(x, y) {
                if (!this.data) return null;
                
                const rect = this.canvas.getBoundingClientRect();
                const canvasWidth = rect.width;
                const totalTime = this.data.duration || this.data.value || 0;
                
                return this.findNodeAtPosition(this.data, 0, 0, canvasWidth, totalTime, x, y);
            }
            
            findNodeAtPosition(node, nodeX, nodeY, width, totalTime, clickX, clickY) {
                const duration = node.duration || node.value || 0;
                const nodeWidth = (duration / totalTime) * width;
                const nodeHeight = this.config.rowHeight;
                
                if (nodeWidth < this.config.minWidth) return null;
                
                // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨å½“å‰èŠ‚ç‚¹èŒƒå›´å†…
                if (clickX >= nodeX && clickX <= nodeX + nodeWidth && 
                    clickY >= nodeY && clickY <= nodeY + nodeHeight) {
                    
                    // å¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œå…ˆæ£€æŸ¥å­èŠ‚ç‚¹
                    if (node.children && node.children.length > 0) {
                        let childX = nodeX;
                        for (const child of node.children) {
                            const childDuration = child.duration || child.value || 0;
                            const childWidth = (childDuration / totalTime) * width;
                            
                            const childNode = this.findNodeAtPosition(
                                child, childX, nodeY + nodeHeight, childWidth, totalTime, clickX, clickY
                            );
                            
                            if (childNode) return childNode;
                            childX += childWidth;
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­èŠ‚ç‚¹ï¼Œè¿”å›å½“å‰èŠ‚ç‚¹
                    return node;
                }
                
                return null;
            }
            
            selectNode(node) {
                this.selectedNode = node;
                this.render();
                
                // è§¦å‘é€‰æ‹©äº‹ä»¶
                const event = new CustomEvent('nodeSelected', { detail: node });
                this.container.dispatchEvent(event);
            }
            
            showTooltip(event) {
                // å·¥å…·æç¤ºå®ç°
            }
            
            setConfig(config) {
                this.config = { ...this.config, ...config };
                this.render();
            }
            
            exportImage() {
                return this.canvas.toDataURL('image/png');
            }
            
            destroy() {
                if (this.canvas) {
                    this.container.removeChild(this.canvas);
                }
                window.removeEventListener('resize', this.resize.bind(this));
            }
        }
        
        // å…¨å±€å˜é‡
        let flameData = null;
        let nodeMap = new Map();
        let maxDepth = 0;
        let selectedNode = null;
        let focusedNode = null;
        let highlightedFunction = null;

        let panOffset = { x: 0, y: 0 };
        let isDragging = false;
        let mouseDownPos = { x: 0, y: 0 };
        let mouseDownTime = 0;
        let lastMousePos = { x: 0, y: 0 };
        let lastClickTime = 0;
        let diffData = null;
        let isDiffMode = false;
        let diffNodeMap = new Map();
        let dataFileList = []; // æ•°æ®æ–‡ä»¶åˆ—è¡¨
        let currentDataIndex = -1; // å½“å‰é€‰ä¸­çš„æ•°æ®ç´¢å¼•
        let diffDataIndex = -1; // å¯¹æ¯”æ•°æ®ç´¢å¼•

        // DOMå…ƒç´ å¼•ç”¨
        const fileInput = document.getElementById('fileInput');
        const jsonTextarea = document.getElementById('jsonTextarea');
        const loadSampleBtn = document.getElementById('loadSampleBtn');      
        const parseJsonBtn = document.getElementById('parseJsonBtn');
        const dataFirstSelect = document.getElementById('dataFirstSelect');
        const dataSecondSelect = document.getElementById('dataSecondSelect');
        const dataFileListElement = document.getElementById('dataFileList');
        const diffLegend = document.getElementById('diffLegend');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        const rowHeightSlider = document.getElementById('rowHeightSlider');
        const rowHeightValue = document.getElementById('rowHeightValue');
        const minWidthSlider = document.getElementById('minWidthSlider');
        const minWidthValue = document.getElementById('minWidthValue');
        const colorSchemeSelect = document.getElementById('colorSchemeSelect');
        const showSystemCalls = document.getElementById('showSystemCalls');
        const showUserCode = document.getElementById('showUserCode');
        const showTooltips = document.getElementById('showTooltips');
        const totalTime = document.getElementById('totalTime');
        const hottestFunction = document.getElementById('hottestFunction');
        const slowFunctions = document.getElementById('slowFunctions');
        const performanceScore = document.getElementById('performanceScore');
        const maxDepthElement = document.getElementById('maxDepth');
        const systemCallRatio = document.getElementById('systemCallRatio');
        const functionDetails = document.getElementById('functionDetails');
        const breadcrumb = document.getElementById('breadcrumb');
        const searchInput = document.getElementById('searchInput');
        const searchClear = document.getElementById('searchClear');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const fitViewBtn = document.getElementById('fitViewBtn');
        const exportBtn = document.getElementById('exportBtn');
        const downloadDataBtn = document.getElementById('downloadDataBtn');
        const flipDataBtn = document.getElementById('flipDataBtn');
        const aggregationResult = document.getElementById('aggregationResult');
        const flameGraphContainer = document.getElementById('flameGraphContainer');
        const emptyState = document.getElementById('emptyState');
        const flameGraph = document.getElementById('flameGraph');

        const statusText = document.getElementById('statusText');
        const tooltip = document.getElementById('tooltip');

        // ç¤ºä¾‹æ•°æ®
        const sampleData = {
            "name": "Main Thread",
            "startTime": 0,
            "duration": 33.42,
            "type": "thread",
            "children": [
                {
                    "name": "Update",
                    "startTime": 0,
                    "duration": 15.67,
                    "type": "user",
                    "children": [
                        {
                            "name": "PlayerController.Update",
                            "startTime": 0.1,
                            "duration": 8.23,
                            "type": "user",
                            "children": [
                                {
                                    "name": "Input.GetAxis",
                                    "startTime": 0.2,
                                    "duration": 2.15,
                                    "type": "system"
                                },
                                {
                                    "name": "Transform.Translate",
                                    "startTime": 2.5,
                                    "duration": 3.8,
                                    "type": "system"
                                },
                                {
                                    "name": "Rigidbody.AddForce",
                                    "startTime": 6.8,
                                    "duration": 1.28,
                                    "type": "system"
                                }
                            ]
                        },
                        {
                            "name": "CameraController.LateUpdate",
                            "startTime": 8.5,
                            "duration": 4.12,
                            "type": "user",
                            "children": [
                                {
                                    "name": "Camera.ScreenToWorldPoint",
                                    "startTime": 8.7,
                                    "duration": 1.95,
                                    "type": "system"
                                },
                                {
                                    "name": "Transform.LookAt",
                                    "startTime": 10.8,
                                    "duration": 1.77,
                                    "type": "system"
                                }
                            ]
                        },
                        {
                            "name": "UI.Update",
                            "startTime": 13.0,
                            "duration": 2.67,
                            "type": "user",
                            "children": [
                                {
                                    "name": "Canvas.Rebuild",
                                    "startTime": 13.2,
                                    "duration": 2.47,
                                    "type": "system"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Render",
                    "startTime": 16.0,
                    "duration": 12.85,
                    "type": "system",
                    "children": [
                        {
                            "name": "Culling",
                            "startTime": 16.2,
                            "duration": 3.45,
                            "type": "system"
                        },
                        {
                            "name": "Shadows",
                            "startTime": 19.8,
                            "duration": 4.23,
                            "type": "system"
                        },
                        {
                            "name": "Opaque",
                            "startTime": 24.2,
                            "duration": 3.67,
                            "type": "system"
                        },
                        {
                            "name": "Transparent",
                            "startTime": 28.0,
                            "duration": 0.85,
                            "type": "system"
                        }
                    ]
                },
                {
                    "name": "Physics.DetectCollisions",
                    "startTime": 29.0,
                    "duration": 4.42,
                    "type": "system",
                    "children": [
                        {
                            "name": "Broadphase",
                            "startTime": 29.2,
                            "duration": 1.23,
                            "type": "system"
                        },
                        {
                            "name": "Narrowphase",
                            "startTime": 30.5,
                            "duration": 2.89,
                            "type": "system"
                        }
                    ]
                }
            ]
        };


        // è§£æJSONæ•°æ®
        function parseJsonData() {
            const jsonText = jsonTextarea.value.trim();
            if (!jsonText) {
                setStatus('è¯·è¾“å…¥JSONæ•°æ®');
                return;
            }
            
            try {
                const data = JSON.parse(jsonText);
                loadFlameData(data);
            } catch (error) {
                setStatus(`JSONè§£æé”™è¯¯: ${error.message}`);
            }
        }

        // æ ‡å‡†åŒ–æ•°æ®æ ¼å¼
        function normalizeDataFormat(data) {
            if (!data) return null;
            
            // æ£€æµ‹å¹¶è½¬æ¢ä¸åŒçš„æ•°æ®æ ¼å¼
            
            // æ ¼å¼1: æ‰å¹³æ•°ç»„æ ¼å¼ [{name, value, children}, ...]
            if (Array.isArray(data) && data.length > 0) {
                // å¦‚æœæ˜¯æ•°ç»„ï¼Œå–ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹
                if (data.length === 1) {
                    return normalizeNode(data[0]);
                } else {
                    // å¤šä¸ªæ ¹èŠ‚ç‚¹ï¼Œåˆ›å»ºä¸€ä¸ªè™šæ‹Ÿæ ¹èŠ‚ç‚¹
                    return {
                        name: "Root",
                        duration: data.reduce((sum, node) => sum + (node.value || node.duration || node.time || 0), 0),
                        startTime: 0,
                        type: "system",
                        children: data.map(node => normalizeNode(node))
                    };
                }
            }
            
            // æ ¼å¼2: å•ä¸ªå¯¹è±¡æ ¼å¼
            if (typeof data === 'object') {
                return normalizeNode(data);
            }
            
            return data;
        }
        
        // æ ‡å‡†åŒ–å•ä¸ªèŠ‚ç‚¹
        function normalizeNode(node) {
            if (!node) return null;
            
            const normalized = {
                name: node.name || node.function || node.method || 'Unknown',
                duration: node.duration || node.value || node.time || node.self || 0,
                startTime: node.startTime || node.start || 0,
                type: node.type || (node.name && node.name.includes('.') ? 'system' : 'user'),
                selfTime: node.selfTime || node.self || 0
            };
            
            // å¤„ç†å­èŠ‚ç‚¹
            if (node.children && Array.isArray(node.children)) {
                normalized.children = node.children.map(child => normalizeNode(child)).filter(child => child !== null);
            } else if (node.calls && Array.isArray(node.calls)) {
                // æ”¯æŒcallså­—æ®µä½œä¸ºchildrençš„åˆ«å
                normalized.children = node.calls.map(child => normalizeNode(child)).filter(child => child !== null);
            }
            
            // å¤„ç†ç‰¹æ®Šæ ¼å¼ï¼šå¦‚æœdurationä¸º0ä½†æœ‰childrenï¼Œè®¡ç®—childrençš„æ€»å’Œ
            if (normalized.duration === 0 && normalized.children && normalized.children.length > 0) {
                normalized.duration = normalized.children.reduce((sum, child) => sum + (child.duration || 0), 0);
            }
            
            return normalized;
        }
        
        // åŠ è½½ç«ç„°å›¾æ•°æ®
        function loadFlameData(rawData) {
            // é¦–å…ˆæ ‡å‡†åŒ–æ•°æ®æ ¼å¼
            const normalizedData = normalizeDataFormat(rawData);
            if (!normalizedData) {
                setStatus('æ•°æ®æ ¼å¼æ— æ•ˆ');
                return;
            }
            
            flameData = normalizedData;
            nodeMap = new Map();
            maxDepth = 0;
            selectedNode = null;
            focusedNode = null;
            highlightedFunction = null;
            
            nodeMap.clear();
            
            // é‡æ–°è®¡ç®—startTimeç¡®ä¿å­èŠ‚ç‚¹ä¸è¶…å‡ºçˆ¶èŠ‚ç‚¹èŒƒå›´
            function recalculateStartTimes(node, parentStartTime = 0) {
                if (!node) return;
                
                node.startTime = parentStartTime;
                
                if (node.children && node.children.length > 0) {
                    if (node.children.length === 1) {
                        // å•ä¸ªå­èŠ‚ç‚¹ï¼šç¡®ä¿ä¸è¶…å‡ºçˆ¶èŠ‚ç‚¹èŒƒå›´
                        const child = node.children[0];
                        // å¦‚æœå­èŠ‚ç‚¹durationå¤§äºç­‰äºçˆ¶èŠ‚ç‚¹ï¼Œåˆ™ä»çˆ¶èŠ‚ç‚¹å¼€å§‹æ—¶é—´å¼€å§‹
                        // å¦åˆ™å±…ä¸­æ˜¾ç¤º
                        let childStartTime;
                        if (child.duration >= node.duration) {
                            childStartTime = parentStartTime;
                            // åŒæ—¶è°ƒæ•´å­èŠ‚ç‚¹durationä¸è¶…è¿‡çˆ¶èŠ‚ç‚¹
                            child.duration = Math.min(child.duration, node.duration);
                        } else {
                            childStartTime = parentStartTime + (node.duration - child.duration) / 2;
                        }
                        recalculateStartTimes(child, childStartTime);
                    } else {
                        // å¤šä¸ªå­èŠ‚ç‚¹ï¼šæŒ‰é¡ºåºæ’åˆ—ï¼Œç¡®ä¿æ€»æ—¶é•¿ä¸è¶…è¿‡çˆ¶èŠ‚ç‚¹
                        let currentTime = parentStartTime;
                        const totalChildDuration = node.children.reduce((sum, child) => sum + child.duration, 0);
                        
                        if (totalChildDuration > node.duration) {
                            // å¦‚æœå­èŠ‚ç‚¹æ€»æ—¶é•¿è¶…è¿‡çˆ¶èŠ‚ç‚¹ï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾
                            const scale = node.duration / totalChildDuration;
                            node.children.forEach(child => {
                                child.duration *= scale;
                            });
                        }
                        
                        node.children.forEach(child => {
                            recalculateStartTimes(child, currentTime);
                            currentTime += child.duration;
                        });
                    }
                }
            }
            
            recalculateStartTimes(flameData);
            processFlameData(flameData, nodeMap);
            updateStats(flameData);
            renderFlameGraph();
            updateBreadcrumb();
            
            emptyState.style.display = 'none';
            functionDetails.textContent = 'ç‚¹å‡»ç«ç„°å›¾ä¸­çš„å‡½æ•°å—æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯';
            setStatus('æ•°æ®åŠ è½½å®Œæˆ');
        }

        // å¤„ç†ç«ç„°å›¾æ•°æ®
        function processFlameData(node, _nodeMap, depth = 0, parentId = null) {
            // æ ‡å‡†åŒ–æ•°æ®å­—æ®µï¼šå°†time/valueå­—æ®µè½¬æ¢ä¸ºduration
            if (!node.duration) {
                if (node.time !== undefined) {
                    node.duration = node.time;
                } else if (node.value !== undefined) {
                    node.duration = node.value;
                } else {
                    node.duration = 0;
                }
            }
            
            // å¤„ç†selfTimeå­—æ®µï¼Œå¦‚æœæ²¡æœ‰åˆ™è®¾ä¸º0
            if (node.selfTime === undefined) {
                node.selfTime = 0;
            }
            
            // è®¾ç½®é»˜è®¤startTime - å±…ä¸­è®¡ç®—
            if (node.startTime === undefined) {
                if (parentId && _nodeMap.has(parentId)) {
                    const parent = _nodeMap.get(parentId);
                    const parentStart = parent.startTime || 0;
                    const parentDuration = parent.duration || 0;
                    const nodeDuration = node.duration || 0;
                    
                    // å¦‚æœå­èŠ‚ç‚¹durationå°äºçˆ¶èŠ‚ç‚¹durationï¼Œåˆ™å±…ä¸­æ”¾ç½®
                    if (nodeDuration < parentDuration) {
                        node.startTime = parentStart + (parentDuration - nodeDuration) / 2;
                    } else {
                        node.startTime = parentStart;
                    }
                } else {
                    node.startTime = 0;
                }
            }
            
            // ç”Ÿæˆå”¯ä¸€ID
            _key = `${node.name}_${depth}`;
            node.id = _key
            node.depth = depth;
            node.parentId = parentId;
            
            // å­˜å‚¨åˆ°æ˜ å°„ä¸­
            _nodeMap.set(_key, node);
            
            // æ›´æ–°æœ€å¤§æ·±åº¦
            maxDepth = Math.max(maxDepth, depth);
            
            // å¤„ç†å­èŠ‚ç‚¹
            if (node.children && node.children.length > 0) {
                if (node.children.length === 1) {
                    // å•ä¸ªå­èŠ‚ç‚¹å·²ç»åœ¨ä¸Šé¢çš„startTimeè®¡ç®—ä¸­å¤„ç†äº†å±…ä¸­é€»è¾‘
                    processFlameData(node.children[0], _nodeMap, depth + 1, node.id);
                } else {
                    // å¤šä¸ªå­èŠ‚ç‚¹æŒ‰é¡ºåºæ’åˆ—ï¼Œé‡æ–°è®¡ç®—startTime
                    let childStartTime = node.startTime || 0;
                    node.children.forEach(child => {
                        // ä¸ºå¤šå­èŠ‚ç‚¹æƒ…å†µé‡æ–°è®¾ç½®startTime
                        child.startTime = childStartTime;
                        processFlameData(child, _nodeMap, depth + 1, node.id);
                        childStartTime += (child.duration || 0);
                    });
                }
            }
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats(data) {
            let functionCount = 0;
            let totalDuration = 0;
            let systemCallCount = 0;
            let slowFunctionCount = 0;
            let hottestNode = null;
            let maxDuration = 0;
            
            function analyzeNodes(node) {
                functionCount++;
                totalDuration += node.duration || 0;
                
                // ç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨
                if (node.type === 'system') {
                    systemCallCount++;
                }
                
                // ç»Ÿè®¡æ…¢å‡½æ•°
                if (node.duration > 10) {
                    slowFunctionCount++;
                }
                
                // æ‰¾åˆ°æœ€è€—æ—¶çš„å‡½æ•°
                if (node.duration > maxDuration) {
                    maxDuration = node.duration;
                    hottestNode = node;
                }
                
                if (node.children) {
                    node.children.forEach(analyzeNodes);
                }
            }
            
            analyzeNodes(data);
            
            // è®¡ç®—æ€§èƒ½è¯„åˆ† (0-100)
            const avgDuration = functionCount > 0 ? totalDuration / functionCount : 0;
            const score = Math.max(0, Math.min(100, 100 - (slowFunctionCount * 10) - (avgDuration * 2)));
            
            // æ›´æ–°æ˜¾ç¤º
            totalTime.textContent = totalDuration.toFixed(2);
            hottestFunction.textContent = hottestNode ? `${hottestNode.name.substring(0, 12)}...` : '-';
            hottestFunction.title = hottestNode ? `${hottestNode.name} (${hottestNode.duration.toFixed(2)}ms)` : '';
            slowFunctions.textContent = slowFunctionCount;
            performanceScore.textContent = Math.round(score);
            maxDepthElement.textContent = maxDepth + 1;
            systemCallRatio.textContent = functionCount > 0 ? `${Math.round((systemCallCount / functionCount) * 100)}%` : '0%';
        }

        // æ¸²æŸ“ç«ç„°å›¾
        function renderFlameGraph() {
            if (!flameData) return;
            
            flameGraph.innerHTML = '';
            
            const containerWidth = flameGraphContainer.clientWidth;
            const rowHeight = parseInt(rowHeightSlider.value);
            const threshold = parseFloat(thresholdSlider.value);
            const minWidth = parseInt(minWidthSlider.value);
            
            // ç¡®å®šæ¸²æŸ“çš„æ ¹èŠ‚ç‚¹
            const rootNode = focusedNode || flameData;
            const baseTime = rootNode.startTime || 0;
            const totalTime = rootNode.duration || 1;
            
            function renderNode(node, depth) {
                // æ£€æŸ¥è¿‡æ»¤æ¡ä»¶
                if (node.duration < threshold) return;
                if (!showSystemCalls.checked && node.type === 'system') return;
                if (!showUserCode.checked && node.type === 'user') return;
                
                // è®¡ç®—ä½ç½®å’Œå¤§å°
                const relativeStart = (node.startTime - baseTime) / totalTime;
                const calculatedWidth = (node.duration / totalTime) * containerWidth * 0.95;
                const width = Math.max(minWidth, calculatedWidth); // åº”ç”¨æœ€å°å®½åº¦é™åˆ¶
                const left = relativeStart * containerWidth * 0.95 + 20;
                const top = (depth - (focusedNode ? focusedNode.depth : 0)) * (rowHeight + 1) + 10;
                
                // å¦‚æœå®½åº¦å¤ªå°ï¼Œè·³è¿‡æ¸²æŸ“ä»¥æé«˜æ€§èƒ½
                if (calculatedWidth < 0.5) return;
                
                // åˆ›å»ºç«ç„°æ¡†å…ƒç´ 
                const box = document.createElement('div');
                box.className = 'flame-box';
                box.dataset.nodeId = node.id;
                box.style.left = `${left}px`;
                box.style.top = `${top}px`;
                box.style.width = `${width}px`;
                box.style.height = `${rowHeight}px`;
                box.style.backgroundColor = getNodeColor(node);
                
                // æ™ºèƒ½æ–‡æœ¬æ˜¾ç¤º - å‚è€ƒ d3-flame-graph çš„æ–‡æœ¬å¤„ç†
                let displayText = '';
                const nodeName = node.name || 'Unknown';
                if (width > 60) {
                    displayText = nodeName;
                } else if (width > 30) {
                    // æˆªæ–­é•¿å‡½æ•°å
                    displayText = nodeName.length > 10 ? nodeName.substring(0, 8) + '..' : nodeName;
                } else if (width > 15) {
                    // åªæ˜¾ç¤ºé¦–å­—æ¯
                    displayText = nodeName.charAt(0);
                }
                
                box.textContent = displayText;
                const duration = node.duration || 0;
                box.title = `${nodeName} (${duration.toFixed(2)}ms)`;
                
                // æ·»åŠ é€‰ä¸­å’Œé«˜äº®çŠ¶æ€
                if (selectedNode && selectedNode.id === node.id) {
                    box.classList.add('selected');
                }
                if (highlightedFunction && nodeName.toLowerCase().includes(highlightedFunction.toLowerCase())) {
                    box.classList.add('highlighted');
                }
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                box.addEventListener('mouseenter', (e) => showTooltip(e, node));
                box.addEventListener('mouseleave', hideTooltip);
                
                flameGraph.appendChild(box);
                
                // æ¸²æŸ“å­èŠ‚ç‚¹
                if (node.children) {
                    node.children.forEach(child => renderNode(child, depth + 1));
                }
            }
            
            renderNode(rootNode, focusedNode ? focusedNode.depth : 0);
        }

        // è·å–èŠ‚ç‚¹é¢œè‰² - æ”¯æŒå¤šç§é…è‰²æ–¹æ¡ˆå’Œdiffæ¨¡å¼
        function getNodeColor(node) {
            // Diffæ¨¡å¼ä¼˜å…ˆ
            if (isDiffMode && node.diffInfo) {
                const diffType = node.diffInfo.diffType;
                switch (diffType) {
                    case 'removed':
                        return '#8e44ad'; // åˆ é™¤çš„å‡½æ•° - ç´«è‰²
                    case 'added':
                        return '#f39c12'; // æ–°å¢å‡½æ•° - æ©™è‰²
                    case 'increased':
                        return '#e74c3c'; // æ€§èƒ½ä¸‹é™ - çº¢è‰²
                    case 'decreased':
                        return '#27ae60'; // æ€§èƒ½æå‡ - ç»¿è‰²
                    default:
                        return '#95a5a6'; // æ— æ˜æ˜¾å˜åŒ– - ç°è‰²
                }
            }
            
            const scheme = colorSchemeSelect.value;
            const hash = hashCode(node.name);
            const hue = Math.abs(hash) % 360;
            
            switch (scheme) {
                case 'performance':
                    // æ€§èƒ½å¯¼å‘é…è‰²
                    if (node.duration > 10) {
                        return `hsl(${(hue + 340) % 360}, 85%, 55%)`; // çº¢è‰²è°ƒ
                    } else if (node.duration > 1) {
                        return `hsl(${(hue + 30) % 360}, 80%, 60%)`; // æ©™é»„è‰²è°ƒ
                    } else if (node.type === 'system') {
                        return `hsl(${(hue + 270) % 360}, 70%, 70%)`; // ç´«è‰²è°ƒ
                    } else {
                        return `hsl(${hue}, 70%, 65%)`;
                    }
                    
                case 'rainbow':
                    // å½©è™¹è‰²è°±
                    return `hsl(${hue}, 80%, 65%)`;
                    
                case 'warm':
                    // æš–è‰²è°ƒ (çº¢ã€æ©™ã€é»„)
                    const warmHue = (hue % 60) + (node.depth % 3) * 60; // 0-180åº¦
                    return `hsl(${warmHue}, 75%, 65%)`;
                    
                case 'cool':
                    // å†·è‰²è°ƒ (è“ã€ç»¿ã€ç´«)
                    const coolHue = ((hue % 120) + 180) % 360; // 180-300åº¦
                    return `hsl(${coolHue}, 75%, 65%)`;
                    
                case 'monochrome':
                    // å•è‰²è°ƒ (ä¸åŒäº®åº¦çš„è“è‰²)
                    const lightness = 40 + (hash % 40); // 40-80%
                    return `hsl(210, 60%, ${lightness}%)`;
                    
                default:
                    return `hsl(${hue}, 70%, 65%)`;
            }
        }
        
        // å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°
        function hashCode(str) {
            if (!str || typeof str !== 'string') {
                return 0;
            }
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
            }
            return hash;
        }

        // æ˜¾ç¤ºå·¥å…·æç¤º
        function showTooltip(event, node) {
            if (!showTooltips.checked) return;
            
            const tooltipTitle = tooltip.querySelector('.tooltip-title');
            const tooltipInfo = tooltip.querySelector('.tooltip-info');
            
            tooltipTitle.textContent = node.name;
            tooltipInfo.innerHTML = `
                <div>æŒç»­æ—¶é—´: ${node.duration.toFixed(2)} ms</div>
                <div>å¼€å§‹æ—¶é—´: ${node.startTime.toFixed(2)} ms</div>
                <div>ç±»å‹: ${node.type}</div>
                <div>æ·±åº¦: ${node.depth}</div>
                ${node.children ? `<div>å­å‡½æ•°: ${node.children.length}</div>` : ''}
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
        }

        // éšè—å·¥å…·æç¤º
        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // æ›´æ–°é˜ˆå€¼
        function updateThreshold() {
            thresholdValue.textContent = thresholdSlider.value;
            renderFlameGraph();
        }

        // æ›´æ–°è¡Œé«˜
        function updateRowHeight() {
            rowHeightValue.textContent = rowHeightSlider.value;
            renderFlameGraph();
        }
        
        // æ›´æ–°æœ€å°å®½åº¦
        function updateMinWidth() {
            minWidthValue.textContent = minWidthSlider.value;
            renderFlameGraph();
        }

        // è®¡ç®—å·®å¼‚
        // ç”Ÿæˆåˆå¹¶çš„diffæ•°æ®
        function generateDiffData(firstData, secondData) {
            if (!firstData || !secondData) return null;
            
            // åˆ›å»ºèŠ‚ç‚¹æ˜ å°„
            const firstNodeMap = new Map();
            const secondNodeMap = new Map();
            
            // æ„å»ºç¬¬ä¸€ä¸ªæ•°æ®é›†çš„èŠ‚ç‚¹æ˜ å°„
            function buildNodeMap(node, map, depth = 0) {
                const nodeKey = `${node.name}_${depth}`;
                map.set(nodeKey, {
                    ...node,
                    depth: depth,
                    duration: node.value || node.duration || 0
                });
                
                if (node.children) {
                    node.children.forEach(child => buildNodeMap(child, map, depth + 1));
                }
            }
            
            buildNodeMap(firstData, firstNodeMap);
            buildNodeMap(secondData, secondNodeMap);
            
            // ç”Ÿæˆåˆå¹¶çš„diffæ•°æ®ç»“æ„
            function createDiffNode(node, depth = 0) {
                const nodeKey = `${node.name}_${depth}`;
                const firstNode = firstNodeMap.get(nodeKey);
                const secondNode = secondNodeMap.get(nodeKey);
                
                const firstDuration = firstNode ? (firstNode.duration || 0) : 0;
                const secondDuration = secondNode ? (secondNode.duration || 0) : 0;
                
                let change = 0;
                let diffType = 'unchanged';
                
                if (!firstNode && secondNode) {
                    // æ–°å¢èŠ‚ç‚¹
                    change = 1;
                    diffType = 'added';
                } else if (firstNode && !secondNode) {
                    // åˆ é™¤èŠ‚ç‚¹
                    change = -1;
                    diffType = 'removed';
                } else if (firstNode && secondNode) {
                    // å˜åŒ–èŠ‚ç‚¹
                    change = firstDuration > 0 ? (secondDuration - firstDuration) / firstDuration : 0;
                    if (Math.abs(change) > 0.1) {
                        diffType = change > 0 ? 'increased' : 'decreased';
                    }
                }
                
                const diffNode = {
                    name: node.name,
                    duration: secondDuration || firstDuration,
                    startTime: 0, // ç¨åé‡æ–°è®¡ç®—
                    depth: depth,
                    id: `${node.name}_${depth}_diff`,
                    children: [],
                    diffInfo: {
                        change: change,
                        oldDuration: firstDuration,
                        newDuration: secondDuration,
                        diffType: diffType,
                        exists: !!firstNode,
                        isRemoved: diffType === 'removed'
                    }
                };
                
                // å¤„ç†å­èŠ‚ç‚¹
                const allChildNames = new Set();
                if (firstNode && firstNode.children) {
                    firstNode.children.forEach(child => allChildNames.add(child.name));
                }
                if (secondNode && secondNode.children) {
                    secondNode.children.forEach(child => allChildNames.add(child.name));
                }
                
                allChildNames.forEach(childName => {
                    const firstChild = firstNode && firstNode.children ? 
                        firstNode.children.find(c => c.name === childName) : null;
                    const secondChild = secondNode && secondNode.children ? 
                        secondNode.children.find(c => c.name === childName) : null;
                    
                    const childNode = secondChild || firstChild;
                    if (childNode) {
                        const diffChild = createDiffNode(childNode, depth + 1);
                        diffNode.children.push(diffChild);
                    }
                });
                
                return diffNode;
            }
            
            // ä»ç¬¬äºŒä¸ªæ•°æ®é›†å¼€å§‹ç”Ÿæˆï¼ˆå› ä¸ºå®ƒåŒ…å«äº†æœ€æ–°çš„ç»“æ„ï¼‰
            return createDiffNode(secondData);
        }
        
        function calculateDiff() {
            if (!flameData || !diffData) return;
            
            // ç”Ÿæˆåˆå¹¶çš„diffæ•°æ®
            const mergedDiffData = generateDiffData(flameData, diffData);
            if (!mergedDiffData) return;
            
            // é‡æ–°è®¡ç®—startTime
            function recalculateStartTimes(node, parentStartTime = 0) {
                if (!node) return;
                
                node.startTime = parentStartTime;
                
                if (node.children && node.children.length > 0) {
                    if (node.children.length === 1) {
                        // å•ä¸ªå­èŠ‚ç‚¹ï¼šç¡®ä¿ä¸è¶…å‡ºçˆ¶èŠ‚ç‚¹èŒƒå›´
                        const child = node.children[0];
                        // å¦‚æœå­èŠ‚ç‚¹durationå¤§äºç­‰äºçˆ¶èŠ‚ç‚¹ï¼Œåˆ™ä»çˆ¶èŠ‚ç‚¹å¼€å§‹æ—¶é—´å¼€å§‹
                        // å¦åˆ™å±…ä¸­æ˜¾ç¤º
                        let childStartTime;
                        if (child.duration >= node.duration) {
                            childStartTime = parentStartTime;
                            // åŒæ—¶è°ƒæ•´å­èŠ‚ç‚¹durationä¸è¶…è¿‡çˆ¶èŠ‚ç‚¹
                            child.duration = Math.min(child.duration, node.duration);
                        } else {
                            childStartTime = parentStartTime + (node.duration - child.duration) / 2;
                        }
                        recalculateStartTimes(child, childStartTime);
                    } else {
                        // å¤šä¸ªå­èŠ‚ç‚¹ï¼šæŒ‰é¡ºåºæ’åˆ—ï¼Œç¡®ä¿æ€»æ—¶é•¿ä¸è¶…è¿‡çˆ¶èŠ‚ç‚¹
                        let currentTime = parentStartTime;
                        const totalChildDuration = node.children.reduce((sum, child) => sum + child.duration, 0);
                        
                        if (totalChildDuration > node.duration) {
                            // å¦‚æœå­èŠ‚ç‚¹æ€»æ—¶é•¿è¶…è¿‡çˆ¶èŠ‚ç‚¹ï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾
                            const scale = node.duration / totalChildDuration;
                            node.children.forEach(child => {
                                child.duration *= scale;
                            });
                        }
                        
                        node.children.forEach(child => {
                            recalculateStartTimes(child, currentTime);
                            currentTime += child.duration;
                        });
                    }
                }
            }
            
            recalculateStartTimes(mergedDiffData);
            
            // æ›¿æ¢å½“å‰çš„flameDataä¸ºåˆå¹¶åçš„diffæ•°æ®
            flameData = mergedDiffData;
        }   

        // å¤„ç†æœç´¢
        function handleSearch() {
            const query = searchInput.value.trim().toLowerCase();
            highlightedFunction = query || null;
            renderFlameGraph();
            
            if (query) {
                setStatus(`æœç´¢: "${query}"`);
            } else {
                setStatus('å°±ç»ª');
            }
        }

        // æ¸…é™¤æœç´¢
        function clearSearch() {
            searchInput.value = '';
            highlightedFunction = null;
            renderFlameGraph();
            setStatus('å·²æ¸…é™¤æœç´¢');
        }

        // é€‰æ‹©èŠ‚ç‚¹
        function selectNode(node) {
            selectedNode = node;
            updateFunctionDetails(node);
            renderFlameGraph();
        }

        // å–æ¶ˆé€‰æ‹©èŠ‚ç‚¹
        function deselectNode() {
            selectedNode = null;
            functionDetails.textContent = 'ç‚¹å‡»ç«ç„°å›¾ä¸­çš„å‡½æ•°å—æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯';
            renderFlameGraph();
        }

        // æ›´æ–°å‡½æ•°è¯¦æƒ…
        function updateFunctionDetails(node) {
            if (!node) {
                functionDetails.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">ç‚¹å‡»ç«ç„°å›¾ä¸­çš„å‡½æ•°å—æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</div>';
                return;
            }
            
            // è®¡ç®—æ€§èƒ½ç­‰çº§
            const getPerformanceLevel = (duration) => {
                if (duration > 10) return { level: 'danger', text: 'æ€§èƒ½ç“¶é¢ˆ' };
                if (duration > 1) return { level: 'warning', text: 'éœ€è¦å…³æ³¨' };
                return { level: 'highlight', text: 'æ€§èƒ½è‰¯å¥½' };
            };
            
            const performance = getPerformanceLevel(node.duration);
            const endTime = node.startTime + node.duration;
            const childCount = node.children ? node.children.length : 0;
            const totalChildTime = node.children ? node.children.reduce((sum, child) => sum + child.duration, 0) : 0;
            const selfTime = node.duration - totalChildTime;
            const selfTimePercent = node.duration > 0 ? (selfTime / node.duration * 100) : 0;
            
            // è®¡ç®—æ€§èƒ½æ¡çš„å®½åº¦ (åŸºäºç›¸å¯¹è€—æ—¶)
            const maxTime = flameData ? flameData.duration : node.duration;
            const performanceWidth = Math.min(100, (node.duration / maxTime) * 100);
            
            functionDetails.innerHTML = `
                <div class="detail-header">
                    ğŸ“Š ${node.name}
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">æ‰§è¡Œæ—¶é—´:</span>
                    <span class="detail-value ${performance.level}">${node.duration.toFixed(2)} ms</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">æ€§èƒ½çŠ¶æ€:</span>
                    <span class="detail-value ${performance.level}">${performance.text}</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">æ—¶é—´èŒƒå›´:</span>
                    <span class="detail-value">${node.startTime.toFixed(2)} - ${endTime.toFixed(2)} ms</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">è‡ªèº«è€—æ—¶:</span>
                    <span class="detail-value">${selfTime.toFixed(2)} ms (${selfTimePercent.toFixed(1)}%)</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">è°ƒç”¨æ·±åº¦:</span>
                    <span class="detail-value">ç¬¬ ${node.depth + 1} å±‚</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">å‡½æ•°ç±»å‹:</span>
                    <span class="detail-value">${node.type === 'system' ? 'ğŸ”§ ç³»ç»Ÿè°ƒç”¨' : 'ğŸ‘¤ ç”¨æˆ·ä»£ç '}</span>
                </div>
                
                <div class="detail-row">
                     <span class="detail-label">å­å‡½æ•°:</span>
                     <span class="detail-value">${childCount} ä¸ª</span>
                 </div>
                 
                 ${node.diffInfo && isDiffMode ? `
                 <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #444;">
                     <div class="detail-header" style="font-size: 13px; margin-bottom: 8px;">ğŸ“Š Diffå¯¹æ¯”</div>
                     
                     <div class="detail-row">
                         <span class="detail-label">å˜åŒ–:</span>
                         <span class="detail-value ${node.diffInfo.change > 0.1 ? 'danger' : node.diffInfo.change < -0.1 ? 'highlight' : ''}">
                             ${node.diffInfo.change > 0 ? '+' : ''}${(node.diffInfo.change * 100).toFixed(1)}%
                         </span>
                     </div>
                     
                     <div class="detail-row">
                         <span class="detail-label">åŸå§‹æ—¶é—´:</span>
                         <span class="detail-value">${node.diffInfo.oldDuration.toFixed(2)} ms</span>
                     </div>
                     
                     <div class="detail-row">
                         <span class="detail-label">å½“å‰æ—¶é—´:</span>
                         <span class="detail-value">${node.diffInfo.newDuration.toFixed(2)} ms</span>
                     </div>
                     
                     <div class="detail-row">
                         <span class="detail-label">çŠ¶æ€:</span>
                         <span class="detail-value">
                             ${node.diffInfo.diffType === 'removed' ? 'ğŸŸ£ åˆ é™¤å‡½æ•°' :
                               node.diffInfo.diffType === 'added' ? 'ğŸŸ  æ–°å¢å‡½æ•°' :
                               node.diffInfo.diffType === 'increased' ? 'ğŸ”´ æ€§èƒ½ä¸‹é™' : 
                               node.diffInfo.diffType === 'decreased' ? 'ğŸŸ¢ æ€§èƒ½æå‡' : 'âšª æ— æ˜æ˜¾å˜åŒ–'}
                         </span>
                     </div>
                 </div>
                 ` : ''}
                 
                 <div style="margin-top: 12px;">
                     <div class="detail-label">ç›¸å¯¹æ€§èƒ½:</div>
                     <div class="performance-bar">
                         <div class="performance-fill" style="width: ${performanceWidth}%"></div>
                     </div>
                 </div>
            `;
        }

        // èšç„¦åˆ°èŠ‚ç‚¹
        function focusNode(node) {
            focusedNode = node;
            selectedNode = null;
            renderFlameGraph();
            updateBreadcrumb();
            setStatus(`å·²èšç„¦åˆ°: ${node.name}`);
        }

        // é‡ç½®èšç„¦
        function resetFocus() {
            focusedNode = null;
            selectedNode = null;
            renderFlameGraph();
            updateBreadcrumb();
            setStatus('å·²é‡ç½®èšç„¦');
        }

        // æ›´æ–°é¢åŒ…å±‘å¯¼èˆª
        function updateBreadcrumb() {
            breadcrumb.innerHTML = '';
            
            // æ„å»ºè·¯å¾„
            const path = [];
            let current = focusedNode;
            
            while (current) {
                path.unshift(current);
                current = current.parentId ? nodeMap.get(current.parentId) : null;
            }
            
            // æ·»åŠ æ ¹èŠ‚ç‚¹
            if (!focusedNode) {
                path.unshift({ id: 'root', name: 'æ ¹èŠ‚ç‚¹' });
            } else {
                path.unshift({ id: 'root', name: 'æ ¹èŠ‚ç‚¹' });
            }
            
            // æ¸²æŸ“é¢åŒ…å±‘
            path.forEach((node, index) => {
                if (index > 0) {
                    const separator = document.createElement('span');
                    separator.className = 'breadcrumb-separator';
                    separator.textContent = '>';
                    breadcrumb.appendChild(separator);
                }
                
                const item = document.createElement('a');
                item.className = 'breadcrumb-item';
                item.href = '#';
                item.textContent = node.name;
                item.dataset.nodeId = node.id;
                breadcrumb.appendChild(item);
            });
        }

        // å¤„ç†é¢åŒ…å±‘ç‚¹å‡»
        function handleBreadcrumbClick(event) {
            event.preventDefault();
            
            if (event.target.classList.contains('breadcrumb-item')) {
                const nodeId = event.target.dataset.nodeId;
                
                if (nodeId === 'root') {
                    resetFocus();
                } else {
                    const node = nodeMap.get(nodeId);
                    if (node) {
                        focusNode(node);
                    }
                }
            }
        }

        // é‡ç½®è§†å›¾å˜æ¢
        function resetViewTransform() {
            panOffset = { x: 0, y: 0 };
            flameGraph.style.transform = 'translate(0px, 0px)';
        }

        // å¤„ç†é¼ æ ‡æŒ‰ä¸‹
        function handleMouseDown(event) {
            mouseDownPos = { x: event.clientX, y: event.clientY };
            mouseDownTime = Date.now();
            isDragging = false;
        }

        // å¤„ç†é¼ æ ‡ç§»åŠ¨
        function handleMouseMove(event) {
            if (mouseDownTime > 0) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œè®¤ä¸ºæ˜¯æ‹–æ‹½
                if (distance > 5) {
                    isDragging = true;
                    lastMousePos = { x: event.clientX, y: event.clientY };
                    flameGraphContainer.style.cursor = 'grabbing';
                    
                    // å¦‚æœæ‹–æ‹½å¼€å§‹äºç«ç„°æ¡†ï¼Œåˆ™éšè—å·¥å…·æç¤º
                    hideTooltip();
                }
            }
        }

        // å¤„ç†é¼ æ ‡æ¾å¼€
        function handleMouseUp(event) {
            // è®¡ç®—é¼ æ ‡æŒ‰ä¸‹çš„æŒç»­æ—¶é—´
            const clickDuration = Date.now() - mouseDownTime;
            
            // å¦‚æœæ²¡æœ‰æ‹–æ‹½ï¼Œä¸”ç‚¹å‡»æ—¶é—´çŸ­ï¼Œåˆ™è®¤ä¸ºæ˜¯ç‚¹å‡»
            if (!isDragging && clickDuration < 200) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯ç«ç„°æ¡†
                if (event.target.classList.contains('flame-box')) {
                    const nodeId = event.target.dataset.nodeId;
                    const node = nodeMap.get(nodeId);
                    
                    if (node) {
                        // åŒºåˆ†å•å‡»å’ŒåŒå‡» - å¢åŠ åŒå‡»æ£€æµ‹æ—¶é—´ä»¥æé«˜å“åº”æ€§
                        const now = Date.now();
                        console.log('ç‚¹å‡»æ—¶é—´é—´éš”:', now - lastClickTime, 'ms', 'å½“å‰é€‰ä¸­èŠ‚ç‚¹:', selectedNode ? selectedNode.name : 'none', 'ç‚¹å‡»èŠ‚ç‚¹:', node.name);
                        
                        if (now - lastClickTime < 400 && selectedNode && selectedNode.id === node.id) {
                            // åŒå‡» - èšç„¦åˆ°èŠ‚ç‚¹ï¼Œæ·»åŠ è§†è§‰åé¦ˆ
                            console.log('è§¦å‘åŒå‡»äº‹ä»¶:', node.name);
                            event.target.style.transform = 'scale(1.05)';
                            setTimeout(() => {
                                event.target.style.transform = '';
                            }, 150);
                            focusNode(node);
                            setStatus(`åŒå‡»èšç„¦: ${node.name}`);
                        } else {
                            // å•å‡» - é€‰æ‹©èŠ‚ç‚¹
                            console.log('è§¦å‘å•å‡»äº‹ä»¶:', node.name);
                            selectNode(node);
                            setStatus(`å·²é€‰æ‹©: ${node.name}`);
                        }
                        lastClickTime = now;
                    }
                } else {
                    // ç‚¹å‡»ç©ºç™½åŒºåŸŸå–æ¶ˆé€‰æ‹©
                    if (selectedNode) {
                        deselectNode();
                        setStatus('å·²å–æ¶ˆé€‰æ‹©');
                    }
                }
            }
            
            // é‡ç½®çŠ¶æ€
            isDragging = false;
            mouseDownTime = 0;
            flameGraphContainer.style.cursor = 'default';
        }

        // å¤„ç†é¼ æ ‡ç¦»å¼€
        function handleMouseLeave() {
            isDragging = false;
            mouseDownTime = 0;
            hideTooltip();
            flameGraphContainer.style.cursor = 'default';
        }

        // é¼ æ ‡æ»šè½®å‚ç›´æ»šåŠ¨
        function handleWheel(event) {
            event.preventDefault();
            
            // å‚ç›´æ»šåŠ¨
            const scrollAmount = event.deltaY;
            panOffset.y -= scrollAmount * 0.5;
            
            flameGraph.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px)`;
        }

        // é€‚åº”è§†å›¾
        function fitFlameGraphToView() {
            if (!flameData) return;
            
            // é‡ç½®æ°´å¹³ä½ç½®å±…ä¸­ï¼Œä¿æŒå‚ç›´ä½ç½®ä¸å˜
            panOffset.x = 0;
            
            flameGraph.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px)`;
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            panOffset = { x: 0, y: 0 };
            searchInput.value = '';
            highlightedFunction = null;
            selectedNode = null;
            focusedNode = null;
            functionDetails.textContent = 'ç‚¹å‡»ç«ç„°å›¾ä¸­çš„å‡½æ•°å—æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯';
            
            renderFlameGraph();
            updateBreadcrumb();
            setStatus('å·²é‡ç½®è§†å›¾');
        }

        // å¯¼å‡ºå›¾ç‰‡
        function exportImage() {
            setStatus('æ­£åœ¨å‡†å¤‡å¯¼å‡º...');
            
            try {
                // ä½¿ç”¨html2canvasåº“å¯¼å‡ºï¼ˆå‡è®¾å·²åŠ è½½ï¼‰
                // æ³¨æ„ï¼šå®é™…å®ç°éœ€è¦åŠ è½½html2canvasåº“
                alert('æ­¤åŠŸèƒ½éœ€è¦html2canvasåº“æ”¯æŒï¼Œè¯·åœ¨å®é™…åº”ç”¨ä¸­é›†æˆ');
                setStatus('å¯¼å‡ºåŠŸèƒ½åœ¨æ­¤æ¼”ç¤ºä¸­ä¸å¯ç”¨');
                
                // html2canvaså®ç°ç¤ºä¾‹ï¼š
                /*
                html2canvas(flameGraph).then(canvas => {
                    const link = document.createElement('a');
                    link.download = 'flame-graph.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    setStatus('å›¾ç‰‡å·²å¯¼å‡º');
                });
                */
            } catch (error) {
                console.error('å¯¼å‡ºå›¾ç‰‡å‡ºé”™:', error);
                setStatus(`å¯¼å‡ºé”™è¯¯: ${error.message}`);
            }
        }

        // ä¸‹è½½å½“å‰æ•°æ®
        function downloadCurrentData() {
            if (!flameData) {
                setStatus('æ²¡æœ‰å¯ä¸‹è½½çš„æ•°æ®');
                return;
            }
            
            try {
                setStatus('æ­£åœ¨å‡†å¤‡ä¸‹è½½...');
                
                // åˆ›å»ºä¸‹è½½æ•°æ®
                const dataToDownload = {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        version: '1.0',
                        description: 'ç«ç„°å›¾æ•°æ®å¯¼å‡º'
                    },
                    data: flameData
                };
                
                // è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                const jsonString = JSON.stringify(dataToDownload, null, 2);
                
                // åˆ›å»ºBlobå¯¹è±¡
                const blob = new Blob([jsonString], { type: 'application/json' });
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                
                // ç”Ÿæˆæ–‡ä»¶å
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.download = `flame-graph-data-${timestamp}.json`;
                
                // è§¦å‘ä¸‹è½½
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // æ¸…ç†URLå¯¹è±¡
                URL.revokeObjectURL(url);
                
                setStatus('æ•°æ®å·²ä¸‹è½½');
                
            } catch (error) {
                console.error('ä¸‹è½½æ•°æ®å‡ºé”™:', error);
                setStatus(`ä¸‹è½½é”™è¯¯: ${error.message}`);
            }
        }

        // è®¾ç½®çŠ¶æ€æ¶ˆæ¯
        function setStatus(message) {
            statusText.textContent = message;
        }

        // æ·»åŠ æ•°æ®åˆ°æ–‡ä»¶åˆ—è¡¨
        function addDataToList(data, name) {
            const dataItem = {
                id: Date.now() + Math.random(),
                name: name,
                data: JSON.parse(JSON.stringify(data)),
                timestamp: new Date().toLocaleString()
            };
            
            dataFileList.push(dataItem);
            updateDataSelectors();
            updateDataFileListDisplay();
            setStatus(`å·²æ·»åŠ æ•°æ®: ${name}`);
        }
        
        // æ›´æ–°æ•°æ®é€‰æ‹©å™¨
        function updateDataSelectors() {
            // æ¸…ç©ºé€‰æ‹©å™¨
            dataFirstSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ•°æ®...</option>';
            dataSecondSelect.innerHTML = '<option value="">æ— å¯¹æ¯”æ•°æ®</option>';
            
            // æ·»åŠ æ•°æ®é€‰é¡¹
            dataFileList.forEach((item, index) => {
                const option1 = document.createElement('option');
                option1.value = index;
                option1.textContent = item.name;
                dataFirstSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = item.name;
                dataSecondSelect.appendChild(option2);
            });
            
            // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªæ•°æ®ï¼Œè‡ªåŠ¨é€‰ä¸­
            if (dataFileList.length === 1) {
                dataFirstSelect.value = '0';
                handleDataFirstChange();
            }
        }
        
        // æ›´æ–°æ•°æ®æ–‡ä»¶åˆ—è¡¨æ˜¾ç¤º
        function updateDataFileListDisplay() {
            if (dataFileList.length === 0) {
                dataFileListElement.innerHTML = '<div style="padding: 10px; text-align: center; color: #666; font-size: 12px;">æš‚æ— æ•°æ®æ–‡ä»¶</div>';
                return;
            }
            
            let html = '';
            dataFileList.forEach((item, index) => {
                const isFirst = index == currentDataIndex;
                const isSecond = index == diffDataIndex;
                const statusText = isFirst ? ' [First]' : (isSecond ? ' [Second]' : '');
                const statusColor = isFirst ? '#4a7c59' : (isSecond ? '#7c4a59' : '#666');
                
                html += `
                    <div class="data-file-item" style="padding: 8px; border-bottom: 1px solid #333; font-size: 12px; color: ${statusColor};">
                        <div style="font-weight: bold;">${item.name}${statusText}</div>
                        <div style="color: #888; font-size: 10px;">${item.timestamp}</div>
                        <button onclick="removeDataItem(${index})" style="float: right; margin-top: -20px; background: #444; border: none; color: #ccc; padding: 2px 6px; border-radius: 2px; cursor: pointer; font-size: 10px;">åˆ é™¤</button>
                    </div>
                `;
            });
            
            dataFileListElement.innerHTML = html;
        }
        
        // åˆ é™¤æ•°æ®é¡¹
        function removeDataItem(index) {
            dataFileList.splice(index, 1);
            
            // æ›´æ–°ç´¢å¼•
            if (currentDataIndex === index) {
                currentDataIndex = -1;
                flameData = null;
            } else if (currentDataIndex > index) {
                currentDataIndex--;
            }
            
            if (diffDataIndex === index) {
                diffDataIndex = -1;
                diffData = null;
                isDiffMode = false;
            } else if (diffDataIndex > index) {
                diffDataIndex--;
            }
            
            updateDataSelectors();
            updateDataFileListDisplay();
            
            // é‡æ–°æ¸²æŸ“
            if (currentDataIndex >= 0 && dataFileList[currentDataIndex]) {
                loadFlameData(dataFileList[currentDataIndex].data);
            } else {
                clearFlameGraph();
            }
        }
        
        // å¤„ç†Firstæ•°æ®é€‰æ‹©å˜åŒ–
        function handleDataFirstChange() {
            const selectedIndex = parseInt(dataFirstSelect.value);
            if (selectedIndex >= 0 && dataFileList[selectedIndex]) {
                currentDataIndex = selectedIndex;
                loadFlameData(dataFileList[selectedIndex].data);
                updateDataFileListDisplay();
                setStatus(`å·²åˆ‡æ¢åˆ°: ${dataFileList[selectedIndex].name}`);
            }
        }
        
        // å¤„ç†Secondæ•°æ®é€‰æ‹©å˜åŒ–
        function handleDataSecondChange() {
            const selectedIndex = parseInt(dataSecondSelect.value);
            
            if (selectedIndex >= 0 && dataFileList[selectedIndex]) {
                diffDataIndex = selectedIndex;
                diffData = dataFileList[selectedIndex].data;
                isDiffMode = true;
                diffLegend.style.display = 'block';
                
                if (flameData) {
                    diffNodeMap.clear();
                    processFlameData(diffData, diffNodeMap);
                    calculateDiff();
                    renderFlameGraph();
                }
                
                updateDataFileListDisplay();
                setStatus(`å·²å¯ç”¨å¯¹æ¯”æ¨¡å¼: ${dataFileList[selectedIndex].name}`);
            } else {
                diffDataIndex = -1;
                diffData = null;
                isDiffMode = false;
                diffLegend.style.display = 'none';
                
                if (flameData) {
                    renderFlameGraph();
                }
                
                updateDataFileListDisplay();
                setStatus('å·²å…³é—­å¯¹æ¯”æ¨¡å¼');
            }
        }
        
        // æ¸…ç©ºç«ç„°å›¾
        function clearFlameGraph() {
            flameData = null;
            nodeMap.clear();
            selectedNode = null;
            focusedNode = null;
            svg.innerHTML = '';
            functionDetails.innerHTML = '<div class="no-selection">ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</div>';
            breadcrumb.innerHTML = '';
            setStatus('å·²æ¸…ç©ºç«ç„°å›¾');
        }
        
        // åŠ è½½ç¤ºä¾‹æ•°æ®
        function loadSampleData() {
            addDataToList(sampleData, 'ç¤ºä¾‹æ•°æ®');
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                try {
                    const data = parseFlameData(content);
                    if (data) {
                        addDataToList(data, file.name);
                        setStatus(`å·²åŠ è½½æ–‡ä»¶: ${file.name}`);
                    } else {
                        setStatus(`æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ: ${file.name}`);
                    }
                } catch (error) {
                    setStatus(`æ–‡ä»¶è§£æé”™è¯¯: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }

        // äº‹ä»¶ç›‘å¬å™¨
        function init() {
            // æ–‡ä»¶è¾“å…¥äº‹ä»¶
            fileInput.addEventListener('change', handleFileUpload);
            parseJsonBtn.addEventListener('click', handleJsonPaste);
            loadSampleBtn.addEventListener('click', loadSampleData);

            // æ•°æ®é€‰æ‹©å™¨äº‹ä»¶
            dataFirstSelect.addEventListener('change', handleDataFirstChange);
            dataSecondSelect.addEventListener('change', handleDataSecondChange);
            
            // è®¾ç½®æ§ä»¶äº‹ä»¶
            thresholdSlider.addEventListener('input', updateThreshold);
            rowHeightSlider.addEventListener('input', updateRowHeight);
            minWidthSlider.addEventListener('input', updateMinWidth);
            colorSchemeSelect.addEventListener('change', renderFlameGraph);
            
            showSystemCalls.addEventListener('change', renderFlameGraph);
            showUserCode.addEventListener('change', renderFlameGraph);
            showTooltips.addEventListener('change', () => {
                if (!showTooltips.checked) hideTooltip();
            });
            
            // æœç´¢äº‹ä»¶
            searchInput.addEventListener('input', handleSearch);
            searchClear.addEventListener('click', clearSearch);
            
            // å·¥å…·æ æŒ‰é’®äº‹ä»¶
            resetViewBtn.addEventListener('click', resetView);
            fitViewBtn.addEventListener('click', fitFlameGraphToView);
            exportBtn.addEventListener('click', exportImage);
            downloadDataBtn.addEventListener('click', downloadCurrentData);
            
            // æ•°æ®èšåˆåŠŸèƒ½äº‹ä»¶
            flipDataBtn.addEventListener('click', handleReverseDataAggregation);
            

            
            // ç«ç„°å›¾å®¹å™¨äº‹ä»¶
            flameGraphContainer.addEventListener('mousedown', handleMouseDown);
            flameGraphContainer.addEventListener('mousemove', handleMouseMove);
            flameGraphContainer.addEventListener('mouseup', handleMouseUp);
            flameGraphContainer.addEventListener('mouseleave', handleMouseLeave);
            flameGraphContainer.addEventListener('wheel', handleWheel);
            
            // é¢åŒ…å±‘å¯¼èˆªäº‹ä»¶
            breadcrumb.addEventListener('click', handleBreadcrumbClick);
            
            // çª—å£å¤§å°å˜åŒ–äº‹ä»¶
            window.addEventListener('resize', () => {
                if (flameData) {
                    renderFlameGraph();
                }
            });
        }
        
        
        // è§£æç«ç„°å›¾æ•°æ®ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
        function parseFlameData(content) {
            if (!content || typeof content !== 'string') {
                throw new Error('å†…å®¹ä¸ºç©ºæˆ–æ ¼å¼æ— æ•ˆ');
            }
            
            const trimmedContent = content.trim();
            
            // å°è¯•è§£æJSONæ ¼å¼
            try {
                return JSON.parse(trimmedContent);
            } catch (jsonError) {
                // JSONè§£æå¤±è´¥ï¼Œå°è¯•å…¶ä»–æ ¼å¼
            }
            
            // å°è¯•è§£æCSVæ ¼å¼ï¼ˆç®€å•çš„è°ƒç”¨æ ˆæ ¼å¼ï¼‰
            if (trimmedContent.includes(',') || trimmedContent.includes(';')) {
                try {
                    return parseCSVFormat(trimmedContent);
                } catch (csvError) {
                    // CSVè§£æå¤±è´¥
                }
            }
            
            // å°è¯•è§£æè°ƒç”¨æ ˆæ–‡æœ¬æ ¼å¼
            if (trimmedContent.includes('\n') && (trimmedContent.includes('ms') || trimmedContent.includes('Î¼s') || trimmedContent.includes('ns'))) {
                try {
                    return parseStackTraceFormat(trimmedContent);
                } catch (stackError) {
                    // è°ƒç”¨æ ˆè§£æå¤±è´¥
                }
            }
            
            // å°è¯•ä¿®å¤å¸¸è§çš„JSONæ ¼å¼é—®é¢˜
            try {
                return parseFlexibleJSON(trimmedContent);
            } catch (flexError) {
                throw new Error(`ä¸æ”¯æŒçš„æ•°æ®æ ¼å¼ã€‚æ”¯æŒçš„æ ¼å¼ï¼šJSONã€CSVã€è°ƒç”¨æ ˆæ–‡æœ¬`);
            }
        }
        
        // è§£æCSVæ ¼å¼
        function parseCSVFormat(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length === 0) throw new Error('CSVå†…å®¹ä¸ºç©º');
            
            const headers = lines[0].split(',').map(h => h.trim());
            const nameIndex = headers.findIndex(h => h.toLowerCase().includes('name') || h.toLowerCase().includes('function'));
            const durationIndex = headers.findIndex(h => h.toLowerCase().includes('duration') || h.toLowerCase().includes('time') || h.toLowerCase().includes('value'));
            
            if (nameIndex === -1) throw new Error('CSVä¸­æœªæ‰¾åˆ°å‡½æ•°ååˆ—');
            if (durationIndex === -1) throw new Error('CSVä¸­æœªæ‰¾åˆ°æ—¶é—´/å€¼åˆ—');
            
            const nodes = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length > Math.max(nameIndex, durationIndex)) {
                    nodes.push({
                        name: values[nameIndex],
                        duration: parseFloat(values[durationIndex]) || 0,
                        type: 'user'
                    });
                }
            }
            
            return {
                name: 'Root',
                duration: nodes.reduce((sum, node) => sum + node.duration, 0),
                children: nodes
            };
        }
        
        // è§£æè°ƒç”¨æ ˆæ–‡æœ¬æ ¼å¼
        function parseStackTraceFormat(content) {
            const lines = content.split('\n').filter(line => line.trim());
            const root = { name: 'Root', duration: 0, children: [] };
            
            lines.forEach(line => {
                const match = line.match(/(.+?)\s+(\d+(?:\.\d+)?)\s*(ms|Î¼s|ns|s)/i);
                if (match) {
                    const name = match[1].trim();
                    let duration = parseFloat(match[2]);
                    const unit = match[3].toLowerCase();
                    
                    // è½¬æ¢ä¸ºæ¯«ç§’
                    if (unit === 's') duration *= 1000;
                    else if (unit === 'Î¼s') duration /= 1000;
                    else if (unit === 'ns') duration /= 1000000;
                    
                    root.children.push({
                        name: name,
                        duration: duration,
                        type: name.includes('.') ? 'system' : 'user'
                    });
                    root.duration += duration;
                }
            });
            
            return root;
        }
        
        // è§£æçµæ´»çš„JSONæ ¼å¼ï¼ˆä¿®å¤å¸¸è§é—®é¢˜ï¼‰
        function parseFlexibleJSON(content) {
            // å°è¯•ä¿®å¤å¸¸è§çš„JSONæ ¼å¼é—®é¢˜
            let fixedContent = content
                .replace(/'/g, '"')  // å•å¼•å·è½¬åŒå¼•å·
                .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')  // å±æ€§ååŠ å¼•å·
                .replace(/,\s*}/g, '}')  // ç§»é™¤å°¾éšé€—å·
                .replace(/,\s*]/g, ']'); // ç§»é™¤æ•°ç»„å°¾éšé€—å·
            
            return JSON.parse(fixedContent);
        }
        
        // å¤„ç†JSONç²˜è´´
        function handleJsonPaste() {
            const jsonText = jsonTextarea.value.trim();
            if (jsonText) {
                try {
                    const data = parseFlameData(jsonText);
                    const timestamp = new Date().toLocaleTimeString();
                    addDataToList(data, `ç²˜è´´æ•°æ®_${timestamp}`);
                    // æ¸…ç©ºæ–‡æœ¬æ¡†
                    jsonTextarea.value = '';
                    setStatus('æ•°æ®è§£ææˆåŠŸ');
                } catch (error) {
                    setStatus(`æ•°æ®è§£æé”™è¯¯: ${error.message}`);
                }
            } else {
                setStatus('è¯·è¾“å…¥æ•°æ®');
            }
        }

        // æ•°æ®å€’è½¬åŠŸèƒ½
        function handleReverseDataAggregation() {
            if (!flameData) {
                setStatus('è¯·å…ˆåŠ è½½æ•°æ®');
                return;
            }
            
            const aggregationInfo = document.querySelector('.aggregation-info');
            
            try {
                const reversedData = reverseCallStack(flameData);
                const resultMessage = 'å·²å®Œæˆæ•°æ®å€’è½¬';
                
                // æ›´æ–°æ•°æ®å¹¶é‡æ–°æ¸²æŸ“
                const timestamp = new Date().toLocaleTimeString();
                addDataToList(reversedData, `å€’è½¬æ•°æ®_${timestamp}`);
                
                // æ˜¾ç¤ºç»“æœä¿¡æ¯
                aggregationResult.textContent = resultMessage;
                aggregationInfo.style.display = 'block';
                
                setStatus(resultMessage);
                
                // 3ç§’åéšè—ç»“æœä¿¡æ¯
                setTimeout(() => {
                    aggregationInfo.style.display = 'none';
                }, 3000);
                
            } catch (error) {
                setStatus(`èšåˆæ“ä½œå¤±è´¥: ${error.message}`);
                aggregationResult.textContent = `é”™è¯¯: ${error.message}`;
                aggregationInfo.style.display = 'block';
            }
        }
        
        // è°ƒç”¨æ ˆå€’è½¬åŠŸèƒ½
        function reverseCallStack(data) {
            const clonedData = JSON.parse(JSON.stringify(data));
            
            // é¦–å…ˆå»ºç«‹èŠ‚ç‚¹æ˜ å°„ï¼Œç”¨äºå¿«é€ŸæŸ¥æ‰¾åŸå§‹èŠ‚ç‚¹ä¿¡æ¯
            const nodeMap = new Map();
            
            function buildNodeMap(node, path = []) {
                const nodePath = [...path, node.name];
                const nodeKey = nodePath.join('>');
                nodeMap.set(nodeKey, {
                    ...node,
                    path: nodePath
                });
                
                if (node.children) {
                    node.children.forEach(child => buildNodeMap(child, nodePath));
                }
            }
            
            buildNodeMap(clonedData);
            
            // æ”¶é›†æ‰€æœ‰ä»æ ¹åˆ°å¶å­çš„å®Œæ•´è·¯å¾„ï¼ŒåŒ…æ‹¬éå¶å­èŠ‚ç‚¹çš„selfæ—¶é—´è·¯å¾„
            function collectAllPaths(node, currentPath = []) {
                const newPath = [...currentPath, {
                    name: node.name,
                    duration: node.duration || 0,
                    type: node.type || 'user',
                    startTime: node.startTime || 0,
                    originalNode: node
                }];
                
                let allPaths = [];
                
                if (!node.children || node.children.length === 0) {
                    // å¶å­èŠ‚ç‚¹ï¼Œè¿”å›å®Œæ•´è·¯å¾„
                    allPaths.push(newPath);
                } else {
                    // éå¶å­èŠ‚ç‚¹ï¼šå…ˆæ”¶é›†å­è·¯å¾„
                    node.children.forEach(child => {
                        const childPaths = collectAllPaths(child, newPath);
                        allPaths = allPaths.concat(childPaths);
                    });
                    
                    // è®¡ç®—å½“å‰èŠ‚ç‚¹çš„selfæ—¶é—´
                    const childrenTotalTime = node.children.reduce((sum, child) => {
                        return sum + (child.duration || 0);
                    }, 0);
                    const selfTime = Math.max(0, (node.duration || 0) - childrenTotalTime);
                    
                    // å¦‚æœselfæ—¶é—´å¤§äº0ï¼Œä¸ºå½“å‰èŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„è·¯å¾„ï¼ˆåªåŒ…å«åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ—¶é—´ä¸ºselfæ—¶é—´ï¼‰
                    if (selfTime > 0) {
                        // åˆ›å»ºä¸€ä¸ªæ–°çš„è·¯å¾„ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„durationè®¾ä¸ºselfTime
                        const selfPath = newPath.map((pathNode, index) => {
                            if (index === newPath.length - 1) {
                                // æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå½“å‰èŠ‚ç‚¹ï¼‰çš„durationè®¾ä¸ºselfTime
                                return {
                                    ...pathNode,
                                    duration: selfTime,
                                    isSelfTime: true
                                };
                            }
                            return pathNode;
                        });
                        allPaths.push(selfPath);
                        console.log('æ·»åŠ selfæ—¶é—´è·¯å¾„:', selfPath.map(n => n.name).join(' -> '), 'æ—¶é—´:', selfTime);
                    }
                }
                
                return allPaths;
            }
            
            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„selfæ—¶é—´
            function calculateSelfTimes(path) {
                const pathWithSelfTime = [];
                
                for (let i = 0; i < path.length; i++) {
                    const pathNode = path[i];
                    const originalNode = pathNode.originalNode;
                    let selfTime;
                    
                    // å¦‚æœæ˜¯selfæ—¶é—´èŠ‚ç‚¹ï¼Œç›´æ¥ä½¿ç”¨å…¶duration
                    if (pathNode.isSelfTime) {
                        selfTime = pathNode.duration;
                    } else {
                        // è®¡ç®—åŸå§‹èŠ‚ç‚¹çš„æ‰€æœ‰ç›´æ¥å­èŠ‚ç‚¹çš„æ€»æ—¶é—´
                        selfTime = originalNode.duration || 0;
                        if (originalNode.children && originalNode.children.length > 0) {
                            const childrenTotalTime = originalNode.children.reduce((sum, child) => {
                                return sum + (child.duration || 0);
                            }, 0);
                            selfTime = Math.max(0, selfTime - childrenTotalTime);
                        }
                    }
                    
                    pathWithSelfTime.push({
                        name: pathNode.name,
                        duration: pathNode.duration,
                        type: pathNode.type,
                        selfTime: selfTime
                    });
                }
                
                return pathWithSelfTime;
            }
            
            const allPaths = collectAllPaths(clonedData);
            
            // æ·»åŠ æ—¥å¿—åˆ†æ
            console.log('=== å€’è½¬æ•°æ®åˆ†æ ===');
            console.log('åŸå§‹æ•°æ®æ ¹èŠ‚ç‚¹:', clonedData.name);
            console.log('æ”¶é›†åˆ°çš„è·¯å¾„æ•°é‡:', allPaths.length);
            console.log('å‰3æ¡è·¯å¾„ç¤ºä¾‹:');
            allPaths.slice(0, 3).forEach((path, index) => {
                console.log(`è·¯å¾„${index + 1}:`, path.map(node => node.name).join(' -> '));
            });
            
            // ä¸ºæ¯ä¸ªè·¯å¾„åˆ›å»ºå€’è½¬åçš„æ ‘ç»“æ„
            const reversedTrees = allPaths.map(path => {
                const pathWithSelfTime = calculateSelfTimes(path);
                // å€’è½¬è·¯å¾„ï¼šå¶å­èŠ‚ç‚¹å˜æˆæ ¹èŠ‚ç‚¹
                const reversedPath = [...pathWithSelfTime].reverse();
                
                console.log('å€’è½¬å‰è·¯å¾„:', pathWithSelfTime.map(node => node.name).join(' -> '));
                console.log('å€’è½¬åè·¯å¾„:', reversedPath.map(node => node.name).join(' -> '));
                
                let currentNode = null;
                
                // ä»å¶å­èŠ‚ç‚¹å¼€å§‹æ„å»ºå€’è½¬çš„æ ‘
                let rootNode = null;
                reversedPath.forEach((pathNode, index) => {
                    const newNode = {
                        name: pathNode.name,
                        duration: pathNode.duration, // ä½¿ç”¨åŸå§‹durationï¼Œä¸æ˜¯selfTime
                        startTime: 0,
                        type: pathNode.type,
                        children: [],
                        selfTime: pathNode.selfTime // ä¿ç•™selfTimeä¿¡æ¯ç”¨äºæ˜¾ç¤º
                    };
                    
                    if (index === 0) {
                        // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯æ–°çš„æ ¹èŠ‚ç‚¹ï¼ˆåŸæ¥çš„å¶å­èŠ‚ç‚¹ï¼‰
                        rootNode = newNode;
                        currentNode = newNode;
                    } else {
                        // åç»­èŠ‚ç‚¹ä½œä¸ºå‰ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
                        currentNode.children = [newNode];
                        currentNode = newNode;
                    }
                });
                
                console.log('æ„å»ºçš„æ ‘æ ¹èŠ‚ç‚¹:', rootNode ? rootNode.name : 'null', 'æ—¶é—´:', rootNode ? rootNode.duration : 'null');
                return rootNode;
            });
            
            console.log('å€’è½¬åçš„æ ‘æ ¹èŠ‚ç‚¹:', reversedTrees.map(tree => tree ? tree.name : 'null'));
            
            // åˆå¹¶ç›¸é‚»çš„åŒåèŠ‚ç‚¹
            function mergeAdjacentNodes(children) {
                if (!children || children.length <= 1) {
                    return children;
                }
                
                const merged = [];
                let i = 0;
                
                while (i < children.length) {
                    let currentNode = { ...children[i], children: [...children[i].children] };
                    let j = i + 1;
                    
                    // æŸ¥æ‰¾ç›¸é‚»çš„åŒåèŠ‚ç‚¹
                    while (j < children.length && children[j].name === currentNode.name) {
                        // åˆå¹¶duration
                        currentNode.duration += children[j].duration;
                        
                        // åˆå¹¶å­èŠ‚ç‚¹
                        const childrenMap = new Map();
                        
                        // æ·»åŠ å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
                        currentNode.children.forEach(child => {
                            childrenMap.set(child.name, { ...child, children: [...child.children] });
                        });
                        
                        // åˆå¹¶ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
                        children[j].children.forEach(child => {
                            if (childrenMap.has(child.name)) {
                                const existingChild = childrenMap.get(child.name);
                                existingChild.duration += child.duration;
                                existingChild.children = existingChild.children.concat(child.children);
                            } else {
                                childrenMap.set(child.name, { ...child, children: [...child.children] });
                            }
                        });
                        
                        currentNode.children = Array.from(childrenMap.values());
                        j++;
                    }
                    
                    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
                    currentNode.children = mergeAdjacentNodes(currentNode.children);
                    
                    // é‡æ–°è®¡ç®—å­èŠ‚ç‚¹çš„startTime
                    let currentTime = 0;
                    currentNode.children.forEach(child => {
                        child.startTime = currentTime;
                        currentTime += child.duration;
                    });
                    
                    merged.push(currentNode);
                    i = j;
                }
                
                return merged;
            }
            
            // æ·±åº¦åˆå¹¶ç›¸åŒåç§°çš„æ ¹èŠ‚ç‚¹å’Œå­æ ‘
            function mergeNodes(node1, node2) {
                // åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹çš„duration
                node1.duration += node2.duration;
                
                // åˆå¹¶å­èŠ‚ç‚¹
                const childrenMap = new Map();
                
                // å…ˆæ·»åŠ node1çš„å­èŠ‚ç‚¹
                node1.children.forEach(child => {
                    childrenMap.set(child.name, { ...child, children: [...child.children] });
                });
                
                // åˆå¹¶node2çš„å­èŠ‚ç‚¹
                node2.children.forEach(child => {
                    if (childrenMap.has(child.name)) {
                        // é€’å½’åˆå¹¶ç›¸åŒåç§°çš„å­èŠ‚ç‚¹
                        mergeNodes(childrenMap.get(child.name), child);
                    } else {
                        childrenMap.set(child.name, { ...child, children: [...child.children] });
                    }
                });
                
                node1.children = Array.from(childrenMap.values());
                
                // åˆå¹¶ç›¸é‚»çš„åŒåå­èŠ‚ç‚¹
                node1.children = mergeAdjacentNodes(node1.children);
                
                // é‡æ–°è®¡ç®—å­èŠ‚ç‚¹çš„startTime
                let currentTime = 0;
                node1.children.forEach(child => {
                    child.startTime = currentTime;
                    currentTime += child.duration;
                });
            }
            
            const mergedRoots = new Map();
            
            reversedTrees.forEach(tree => {
                if (tree) {
                    const rootName = tree.name;
                    if (mergedRoots.has(rootName)) {
                        const existingRoot = mergedRoots.get(rootName);
                        mergeNodes(existingRoot, tree);
                    } else {
                        mergedRoots.set(rootName, { ...tree, children: [...tree.children] });
                    }
                }
            });
            
            console.log('åˆå¹¶åçš„æ ¹èŠ‚ç‚¹åç§°:', Array.from(mergedRoots.keys()));
            
            // ç›´æ¥è¿”å›åˆå¹¶åçš„æ ¹èŠ‚ç‚¹æ•°ç»„ï¼Œä¸å†åˆ›å»ºæ–°çš„åŒ…è£…æ ¹èŠ‚ç‚¹
            let newRootChildren = Array.from(mergedRoots.values());
            
            // å¯¹æ ¹èŠ‚ç‚¹ä¹Ÿåº”ç”¨ç›¸é‚»èŠ‚ç‚¹åˆå¹¶
            newRootChildren = mergeAdjacentNodes(newRootChildren);
            
            let currentTime = 0;
            newRootChildren.forEach(child => {
                child.startTime = currentTime;
                currentTime += child.duration;
            });
            
            console.log('æœ€ç»ˆè¿”å›çš„æ ¹èŠ‚ç‚¹æ•°é‡:', newRootChildren.length);
            console.log('æœ€ç»ˆæ ¹èŠ‚ç‚¹åç§°:', newRootChildren.map(child => child.name));
            
            // å¦‚æœåªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›å®ƒï¼›å¦‚æœæœ‰å¤šä¸ªï¼Œåˆ›å»ºä¸€ä¸ªè™šæ‹Ÿæ ¹èŠ‚ç‚¹
            if (newRootChildren.length === 1) {
                console.log('è¿”å›å•ä¸ªæ ¹èŠ‚ç‚¹:', newRootChildren[0].name);
                return newRootChildren[0];
            } else {
                console.log('è¿”å›å¤šä¸ªæ ¹èŠ‚ç‚¹ï¼Œåˆ›å»ºè™šæ‹Ÿæ ¹èŠ‚ç‚¹');
                return {
                    name: 'å€’è½¬è°ƒç”¨æ ˆ (å¤šä¸ªæ ¹èŠ‚ç‚¹)',
                    duration: newRootChildren.reduce((sum, child) => sum + child.duration, 0),
                    startTime: 0,
                    type: 'root',
                    children: newRootChildren
                };
            }
        }
        

        
        // åˆå§‹åŒ–
        init();
        
        // å»¶è¿ŸåŠ è½½ç¤ºä¾‹æ•°æ®ï¼ˆæ¨¡æ‹Ÿï¼‰
        // setTimeout(loadSampleData, 500);
    </script>
</body>
</html>