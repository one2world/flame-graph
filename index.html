<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity性能分析火焰图工具</title>
    <style>
        /* 整合的完整CSS样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 20px;
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background-color: #1976D2;
        }

        .btn-generate {
            background-color: #4CAF50;
            color: white;
            width: 100%;
            margin-top: 20px;
        }

        .btn-generate:hover {
            background-color: #45a049;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background-color: #e8f5e8;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #2e7d32;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #4CAF50;
        }

        .file-input-container {
            position: relative;
            margin-bottom: 16px;
        }

        .file-label {
            display: block;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-label:hover {
            background-color: #45a049;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .import-info {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 10px;
        }

        .stats {
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .stat-item .label {
            font-size: 12px;
            color: #555;
            flex: 1;
        }

        .stat-item input {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
            text-align: center;
        }

        .checkboxes {
            margin-bottom: 15px;
        }

        .checkboxes label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .checkboxes input[type="checkbox"] {
            margin-right: 8px;
        }

        .dropdown {
            margin-bottom: 15px;
        }

        .dropdown label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #555;
        }

        .dropdown select {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: white;
        }

        .stats-display {
            background-color: #f0f8f0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .stat-row:last-child {
            margin-bottom: 0;
        }

        .stat-row .label {
            color: #555;
        }

        .function-details {
            background-color: #f0f8f0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
        }

        .detail-item {
            margin-bottom: 15px;
        }

        .detail-label {
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .detail-stats {
            font-size: 12px;
            color: #555;
        }

        .detail-stats div {
            margin-bottom: 4px;
        }

        .time-value {
            color: #ff6b35;
            font-weight: bold;
        }

        .percentage {
            color: #4CAF50;
            font-weight: bold;
        }

        .call-count, .child-count {
            color: #2196F3;
            font-weight: bold;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        .search-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .search-bar input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .breadcrumb {
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
            background-color: #f9f9f9;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .breadcrumb span {
            color: #2196F3;
            cursor: pointer;
        }

        .breadcrumb span:hover {
            text-decoration: underline;
        }

        .flame-graph-container {
            flex: 1;
            position: relative;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        #flameGraph {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .color-box {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            border: 1px solid #ddd;
        }

        /* 响应式设计 */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 300px;
            }
            
            .main-content {
                min-height: 400px;
            }
        }

        /* 滚动条样式 */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }

        /* 动画效果 */
        .section {
            transition: all 0.3s ease;
        }

        .section:hover {
            transform: translateY(-1px);
        }

        .btn {
            transition: all 0.2s ease;
        }

        .btn:active {
            transform: translateY(1px);
        }

        /* 原有样式继续保持 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2d5a27, #4a7c59);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .header .subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .main-layout {
            display: flex;
            height: calc(100vh - 70px);
        }

        .sidebar {
            width: 300px;
            background: #2a2a2a;
            border-right: 1px solid #444;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar-section {
            border-bottom: 1px solid #444;
            padding: 15px;
        }

        .sidebar-section h3 {
            color: #4a7c59;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .data-import {
            background: #333;
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 10px;
        }

        .file-input {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .json-paste {
            margin-top: 10px;
        }

        .json-textarea {
            width: 100%;
            height: 80px;
            padding: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .btn {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #5a8c69;
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .display-settings {
            background: #2a2a2a;
        }

        /* 需要水平布局的两项容器 */
        .horizontal-items {
            display: flex; /* 启用flex布局 */
            gap: 10px;    /* 项之间的间距 */
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            font-size: 12px;
            color: #999;
        }

        .checkbox-group {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .color-scheme-select {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .color-scheme-select option {
            background: #444;
            color: #e0e0e0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4a7c59;
        }

        .stat-label {
            font-size: 12px;
            color: #999;
            margin-top: 2px;
        }

        .function-details {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            border: 1px solid #444;
        }

        .function-details .detail-header {
            color: #4a7c59;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }

        .function-details .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
        }

        .function-details .detail-label {
            color: #ccc;
            font-weight: 500;
        }

        .function-details .detail-value {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
        }

        .function-details .detail-value.highlight {
            color: #4a7c59;
            font-weight: bold;
        }

        .function-details .detail-value.warning {
            color: #f39c12;
        }

        .function-details .detail-value.danger {
            color: #e74c3c;
        }

        .function-details .performance-bar {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .function-details .performance-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a7c59, #f39c12, #e74c3c);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
        }

        .breadcrumb {
            background: #2a2a2a;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            font-size: 14px;
            white-space: nowrap;
            overflow-x: auto;
        }

        .breadcrumb-item {
            color: #4a7c59;
            cursor: pointer;
            text-decoration: none;
        }

        .breadcrumb-item:hover {
            text-decoration: underline;
        }

        .breadcrumb-separator {
            margin: 0 8px;
            color: #666;
        }

        .toolbar {
            background: #2a2a2a;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .search-box {
            flex: 1;
            max-width: 300px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 8px 35px 8px 12px;
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 16px;
        }

        .flame-graph-container {
            flex: 1;
            position: relative;
            overflow-x: hidden;
            overflow-y: auto;
            background: #1a1a1a;
        }
        
        .flame-graph-container::-webkit-scrollbar {
            width: 12px;
        }
        
        .flame-graph-container::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        
        .flame-graph-container::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 6px;
        }
        
        .flame-graph-container::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        .flame-graph {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .flame-box {
            position: absolute;
            border: 1px solid rgba(0,0,0,0.2);
            cursor: pointer;
            font-size: 11px;
            color: #000;
            font-weight: 500;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            padding: 2px 4px;
            box-sizing: border-box;
            transition: all 0.15s ease;
            border-radius: 2px;
            text-shadow: 0 1px 0 rgba(255,255,255,0.3);
        }

        .flame-box:hover {
            border-color: rgba(0,0,0,0.6);
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transform: translateY(-1px);
            filter: brightness(1.1);
        }

        .flame-box.selected {
            border: 2px solid #2c5aa0;
            z-index: 101;
            box-shadow: 0 0 0 1px rgba(44, 90, 160, 0.3);
        }

        .flame-box.highlighted {
            border: 2px solid #e74c3c;
            z-index: 102;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3);
        }

        @keyframes pulse {
            0%, 100% { 
                box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3), 0 0 10px rgba(231, 76, 60, 0.2); 
            }
            50% { 
                box-shadow: 0 0 0 4px rgba(231, 76, 60, 0.5), 0 0 20px rgba(231, 76, 60, 0.4); 
            }
        }



        .status-bar {
            background: #2a2a2a;
            padding: 8px 15px;
            border-top: 1px solid #444;
            font-size: 12px;
            color: #999;
        }

        .tooltip {
            position: absolute;
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid #666;
            border-radius: 4px;
            padding: 8px;
            font-size: 12px;
            color: #e0e0e0;
            pointer-events: none;
            z-index: 1001;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: #4a7c59;
        }

        .tooltip-info {
            line-height: 1.4;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 16px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        ::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>Unity性能分析工具</h1>
            <div class="subtitle">函数调用时序火焰图</div>
        </div>
    </div>

    <div class="main-layout">
        <div class="sidebar">
            <div class="sidebar-section data-import">
                <h3>数据导入</h3>
                <div class="file-input-container">
                    <input type="file" id="fileInput" accept=".json" style="display: none;" />
                    <label for="fileInput" class="file-input-button">选择JSON文件</label>
                </div>
                <div class="json-paste">
                    <textarea id="jsonTextarea" class="json-textarea" placeholder="或粘贴JSON数据..."></textarea>
                </div>
                <button id="parseJsonBtn" class="btn">添加JSON数据</button>
                <div class="horizontal-items">
                    <button id="loadSampleBtn" class="btn">添加示例数据</button>
                </div>
                
                <!-- 数据聚合功能 -->
                <div class="data-aggregation-section" style="margin-top: 15px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #4a7c59;">🔄 数据聚合</h4>
                    <div class="aggregation-controls">
                        <button id="flipDataBtn" class="btn btn-secondary" style="width: 100%; margin-bottom: 8px;">数据倒转</button>
                        <div class="aggregation-info" style="font-size: 11px; color: #888; padding: 8px; background: #f9f9f9; border-radius: 3px; display: none;">
                            <div id="aggregationResult">等待聚合操作...</div>
                        </div>
                    </div>
                </div>

                <!-- 数据文件列表 -->
                <div class="data-list-section" style="margin-top: 15px;">
                    <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #4a7c59;">📁 数据文件列表</h4>
                    <div class="data-selector">
                        <label style="font-size: 12px; color: #ccc; margin-bottom: 5px; display: block;">数据列表 First:</label>
                        <select id="dataFirstSelect" class="data-select" style="width: 100%; margin-bottom: 10px; padding: 5px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 3px;">
                            <option value="">请选择数据...</option>
                        </select>
                        
                        <label style="font-size: 12px; color: #ccc; margin-bottom: 5px; display: block;">数据列表 Second (可选):</label>
                        <select id="dataSecondSelect" class="data-select" style="width: 100%; margin-bottom: 10px; padding: 5px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 3px;">
                            <option value="">无对比数据</option>
                        </select>
                    </div>
                    
                    <!-- 数据文件列表显示 -->
                    <div id="dataFileList" class="data-file-list" style="max-height: 120px; overflow-y: auto; border: 1px solid #444; border-radius: 3px; background: #1a1a1a;">
                        <div style="padding: 10px; text-align: center; color: #666; font-size: 12px;">暂无数据文件</div>
                    </div>
                    
                    <!-- Diff图例 -->
                    <div id="diffLegend" class="diff-legend" style="margin-top: 10px; font-size: 11px; display: none;">
                        <div class="horizontal-items">
                            <div style="color: #e74c3c; margin-bottom: 2px;">🔴 性能下降</div>
                            <div style="color: #27ae60; margin-bottom: 2px;">🟢 性能提升</div>
                            <div style="color: #f39c12; margin-bottom: 2px;">🟠 新增函数</div>
                            <div style="color: #8e44ad; margin-bottom: 2px;">🟣 删除函数</div>
                            <div style="color: #95a5a6;">⚪ 无明显变化</div>
                        </div>
                    </div>
                </div>
            </div>            

            <div class="sidebar-section">
                <h3>性能分析</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalTime">0</div>
                        <div class="stat-label">总执行时间(ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="hottestFunction">-</div>
                        <div class="stat-label">性能热点</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="slowFunctions">0</div>
                        <div class="stat-label">慢函数(>10ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="performanceScore">0</div>
                        <div class="stat-label">性能评分</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="maxDepth">0</div>
                        <div class="stat-label">调用深度</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="systemCallRatio">0%</div>
                        <div class="stat-label">系统调用占比</div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>函数详情</h3>
                <div id="functionDetails" class="function-details">
                    点击火焰图中的函数块查看详细信息
                </div>
            </div>

            
            <div class="sidebar-section display-settings">
                <h3>显示设置</h3>
                <div class="setting-item">
                    <label>时间阈值 (ms)</label>
                    <input type="range" id="thresholdSlider" class="slider" min="0" max="10" step="0.1" value="0.1">
                    <div class="slider-value" id="thresholdValue">0.1</div>
                </div>
                <div class="setting-item">
                    <label>行高 (px)</label>
                    <input type="range" id="rowHeightSlider" class="slider" min="15" max="40" step="1" value="24">
                    <div class="slider-value" id="rowHeightValue">24</div>
                </div>
                <div class="setting-item">
                    <label>最小宽度 (px)</label>
                    <input type="range" id="minWidthSlider" class="slider" min="1" max="20" step="1" value="3">
                    <div class="slider-value" id="minWidthValue">3</div>
                </div>                
            </div>
        </div>

        <div class="content-area">
            <div id="breadcrumb" class="breadcrumb">
                <a href="#" class="breadcrumb-item" data-node-id="root">根节点</a>
            </div>

            <div class="toolbar">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input" placeholder="搜索函数名...">
                    <button id="searchClear" class="search-clear">×</button>
                </div>
                <button id="resetViewBtn" class="btn">重置视图</button>
                <button id="fitViewBtn" class="btn">适应视图</button>
                <button id="exportBtn" class="btn">导出图片</button>
                <button id="downloadDataBtn" class="btn">下载数据</button>

                <div class="setting-item">
                    <label>配色方案</label>
                    <select id="colorSchemeSelect" class="color-scheme-select">
                        <option value="performance">性能导向</option>
                        <option value="rainbow">彩虹色谱</option>
                        <option value="warm">暖色调</option>
                        <option value="cool">冷色调</option>
                        <option value="monochrome">单色调</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>显示选项</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="showSystemCalls" checked>
                            <label for="showSystemCalls">显示系统调用</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showUserCode" checked>
                            <label for="showUserCode">显示用户代码</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showTooltips" checked>
                            <label for="showTooltips">显示工具提示</label>
                        </div>
                    </div>
                </div>

            </div>

            <div id="flameGraphContainer" class="flame-graph-container">
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">📊</div>
                    <div>请导入JSON数据文件或加载示例数据开始分析</div>
                </div>
                <div id="flameGraph" class="flame-graph"></div>            
            </div>

            <div class="status-bar">
                <span id="statusText">就绪</span>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip" style="display: none;">
        <div class="tooltip-title"></div>
        <div class="tooltip-info"></div>
    </div>

    <script>
        // FlameGraph类 - 整合自flame-graph.js
        class FlameGraph {
            constructor(container, options = {}) {
                this.container = container;
                this.canvas = null;
                this.ctx = null;
                this.data = null;
                this.nodeMap = new Map();
                this.maxDepth = 0;
                this.selectedNode = null;
                this.focusedNode = null;
                this.highlightedFunction = null;

                this.panOffset = { x: 0, y: 0 };
                this.isDragging = false;
                this.mouseDownPos = { x: 0, y: 0 };
                this.mouseDownTime = 0;
                this.lastMousePos = { x: 0, y: 0 };
                this.lastClickTime = 0;
                this.diffData = null;
                this.isDiffMode = false;
                this.diffNodeMap = new Map();
                
                // 配置选项
                this.config = {
                    rowHeight: options.rowHeight || 20,
                    minWidth: options.minWidth || 1,
                    threshold: options.threshold || 0.1,
                    colorScheme: options.colorScheme || 'default',
                    showLabels: options.showLabels !== false,
                    showTooltip: options.showTooltip !== false,
                    ...options
                };
                
                // 颜色方案
                this.colorSchemes = {
                    default: {
                        normal: ['#ff6b35', '#f7931e', '#ffd23f', '#06ffa5', '#1fb3d3', '#5d4e75'],
                        hot: '#ff4444',
                        cold: '#4444ff',
                        neutral: '#888888'
                    },
                    warm: {
                        normal: ['#ff9999', '#ffcc99', '#ffff99', '#ccff99', '#99ffcc', '#99ccff'],
                        hot: '#ff6666',
                        cold: '#6666ff',
                        neutral: '#999999'
                    },
                    cool: {
                        normal: ['#99ccff', '#99ffcc', '#ccff99', '#ffff99', '#ffcc99', '#ff9999'],
                        hot: '#6666ff',
                        cold: '#ff6666',
                        neutral: '#999999'
                    }
                };
                
                this.init();
            }
            
            init() {
                this.createCanvas();
                this.bindEvents();
            }
            
            createCanvas() {
                this.canvas = document.createElement('canvas');
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.cursor = 'crosshair';
                this.container.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                this.resize();
            }
            
            bindEvents() {
                // 鼠标事件
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.onWheel.bind(this));
                this.canvas.addEventListener('dblclick', this.onDoubleClick.bind(this));
                
                // 窗口大小变化
                window.addEventListener('resize', this.resize.bind(this));
            }
            
            resize() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.render();
            }
            
            setData(data) {
                this.data = data;
                this.processData();
                this.render();
            }
            
            processData() {
                if (!this.data) return;
                
                this.nodeMap.clear();
                this.maxDepth = 0;
                this.processNode(this.data, 0, 0, this.data.duration || this.data.value || 0);
            }
            
            processNode(node, depth, startTime, totalTime) {
                const duration = node.duration || node.value || 0;
                const selfTime = node.selfTime || duration;

                node.id = node.id || `${node.name}_${depth}`;
                node.depth = depth;
                node.startTime = startTime;
                node.duration = duration;
                node.selfTime = selfTime;
                node.percentage = totalTime > 0 ? (duration / totalTime) * 100 : 0;
                
                this.nodeMap.set(node.id, node);
                this.maxDepth = Math.max(this.maxDepth, depth);
                
                if (node.children && node.children.length > 0) {
                    // 如果只有一个子节点，居中放置
                    if (node.children.length === 1) {
                        const child = node.children[0];
                        const childDuration = child.duration || child.value || 0;
                        const centerStart = startTime + (duration - childDuration) / 2;
                        this.processNode(child, depth + 1, centerStart, totalTime);
                    } else {
                        // 多个子节点按顺序排列
                        let childStartTime = startTime;
                        node.children.forEach(child => {
                            const childDuration = child.duration || child.value || 0;
                            this.processNode(child, depth + 1, childStartTime, totalTime);
                            childStartTime += childDuration;
                        });
                    }
                }
            }
            
            render() {
                if (!this.canvas || !this.data) return;
                
                const rect = this.container.getBoundingClientRect();
                this.ctx.clearRect(0, 0, rect.width, rect.height);
                
                this.renderNode(this.data, 0, 0, rect.width, this.data.duration || this.data.value || 0);
            }
            
            renderNode(node, x, y, width, totalTime) {
                const duration = node.duration || node.value || 0;
                const nodeWidth = (duration / totalTime) * width;
                const nodeHeight = this.config.rowHeight;
                
                if (nodeWidth < this.config.minWidth) return;
                
                // 计算颜色
                const color = this.getNodeColor(node);
                
                // 绘制节点
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, nodeWidth, nodeHeight);
                
                // 绘制边框
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 0.5;
                this.ctx.strokeRect(x, y, nodeWidth, nodeHeight);
                
                // 绘制文本
                if (this.config.showLabels && nodeWidth > 50) {
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'middle';
                    
                    const text = this.truncateText(node.name || 'Unknown', nodeWidth - 4);
                    this.ctx.fillText(text, x + 2, y + nodeHeight / 2);
                }
                
                // 递归绘制子节点
                if (node.children && node.children.length > 0) {
                    let childX = x;
                    node.children.forEach(child => {
                        const childDuration = child.duration || child.value || 0;
                        const childWidth = (childDuration / totalTime) * width;
                        this.renderNode(child, childX, y + nodeHeight, childWidth, totalTime);
                        childX += childWidth;
                    });
                }
            }
            
            getNodeColor(node) {
                const colors = this.colorSchemes[this.config.colorScheme].normal;
                const hash = this.hashString(node.name || 'Unknown');
                return colors[hash % colors.length];
            }
            
            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            truncateText(text, maxWidth) {
                const metrics = this.ctx.measureText(text);
                if (metrics.width <= maxWidth) return text;
                
                let truncated = text;
                while (this.ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                    truncated = truncated.slice(0, -1);
                }
                return truncated + '...';
            }
            
            onMouseDown(event) {
                this.isDragging = true;
                this.mouseDownPos = { x: event.clientX, y: event.clientY };
                this.mouseDownTime = Date.now();
                this.canvas.style.cursor = 'grabbing';
            }
            
            onMouseMove(event) {
                if (this.isDragging) {
                    const deltaX = event.clientX - this.lastMousePos.x;
                    const deltaY = event.clientY - this.lastMousePos.y;
                    this.panOffset.x += deltaX;
                    this.panOffset.y += deltaY;
                    this.render();
                }
                
                this.lastMousePos = { x: event.clientX, y: event.clientY };
                
                // 显示工具提示
                if (this.config.showTooltip) {
                    this.showTooltip(event);
                }
            }
            
            onMouseUp(event) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'crosshair';
                    
                    // 检查是否是点击而不是拖拽
                    const timeDiff = Date.now() - this.mouseDownTime;
                    const distance = Math.sqrt(
                        Math.pow(event.clientX - this.mouseDownPos.x, 2) +
                        Math.pow(event.clientY - this.mouseDownPos.y, 2)
                    );
                    
                    if (timeDiff < 300 && distance < 5) {
                        this.onClick(event);
                    }
                }
            }
            
            // onWheel(event) {
            //     event.preventDefault();
            //     const delta = event.deltaY > 0 ? 0.9 : 1.1;
            //     this.zoomLevel *= delta;
            //     this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
            //     this.render();
            // }
            
            onDoubleClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const clickedNode = this.getNodeAtPosition(x, y);
                if (clickedNode) {
                    this.selectNode(clickedNode);
                    // 可以添加双击特殊处理，比如聚焦到节点
                    console.log('双击选中节点:', clickedNode.name);
                }
            }
            
            onClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const clickedNode = this.getNodeAtPosition(x, y);
                if (clickedNode) {
                    this.selectNode(clickedNode);
                }
            }
            
            getNodeAtPosition(x, y) {
                if (!this.data) return null;
                
                const rect = this.canvas.getBoundingClientRect();
                const canvasWidth = rect.width;
                const totalTime = this.data.duration || this.data.value || 0;
                
                return this.findNodeAtPosition(this.data, 0, 0, canvasWidth, totalTime, x, y);
            }
            
            findNodeAtPosition(node, nodeX, nodeY, width, totalTime, clickX, clickY) {
                const duration = node.duration || node.value || 0;
                const nodeWidth = (duration / totalTime) * width;
                const nodeHeight = this.config.rowHeight;
                
                if (nodeWidth < this.config.minWidth) return null;
                
                // 检查点击是否在当前节点范围内
                if (clickX >= nodeX && clickX <= nodeX + nodeWidth && 
                    clickY >= nodeY && clickY <= nodeY + nodeHeight) {
                    
                    // 如果有子节点，先检查子节点
                    if (node.children && node.children.length > 0) {
                        let childX = nodeX;
                        for (const child of node.children) {
                            const childDuration = child.duration || child.value || 0;
                            const childWidth = (childDuration / totalTime) * width;
                            
                            const childNode = this.findNodeAtPosition(
                                child, childX, nodeY + nodeHeight, childWidth, totalTime, clickX, clickY
                            );
                            
                            if (childNode) return childNode;
                            childX += childWidth;
                        }
                    }
                    
                    // 如果没有找到子节点，返回当前节点
                    return node;
                }
                
                return null;
            }
            
            selectNode(node) {
                this.selectedNode = node;
                this.render();
                
                // 触发选择事件
                const event = new CustomEvent('nodeSelected', { detail: node });
                this.container.dispatchEvent(event);
            }
            
            showTooltip(event) {
                // 工具提示实现
            }
            
            setConfig(config) {
                this.config = { ...this.config, ...config };
                this.render();
            }
            
            exportImage() {
                return this.canvas.toDataURL('image/png');
            }
            
            destroy() {
                if (this.canvas) {
                    this.container.removeChild(this.canvas);
                }
                window.removeEventListener('resize', this.resize.bind(this));
            }
        }
        
        // 全局变量
        let flameData = null;
        let nodeMap = new Map();
        let maxDepth = 0;
        let selectedNode = null;
        let focusedNode = null;
        let highlightedFunction = null;

        let panOffset = { x: 0, y: 0 };
        let isDragging = false;
        let mouseDownPos = { x: 0, y: 0 };
        let mouseDownTime = 0;
        let lastMousePos = { x: 0, y: 0 };
        let lastClickTime = 0;
        let diffData = null;
        let isDiffMode = false;
        let diffNodeMap = new Map();
        let dataFileList = []; // 数据文件列表
        let currentDataIndex = -1; // 当前选中的数据索引
        let diffDataIndex = -1; // 对比数据索引

        // DOM元素引用
        const fileInput = document.getElementById('fileInput');
        const jsonTextarea = document.getElementById('jsonTextarea');
        const loadSampleBtn = document.getElementById('loadSampleBtn');      
        const parseJsonBtn = document.getElementById('parseJsonBtn');
        const dataFirstSelect = document.getElementById('dataFirstSelect');
        const dataSecondSelect = document.getElementById('dataSecondSelect');
        const dataFileListElement = document.getElementById('dataFileList');
        const diffLegend = document.getElementById('diffLegend');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        const rowHeightSlider = document.getElementById('rowHeightSlider');
        const rowHeightValue = document.getElementById('rowHeightValue');
        const minWidthSlider = document.getElementById('minWidthSlider');
        const minWidthValue = document.getElementById('minWidthValue');
        const colorSchemeSelect = document.getElementById('colorSchemeSelect');
        const showSystemCalls = document.getElementById('showSystemCalls');
        const showUserCode = document.getElementById('showUserCode');
        const showTooltips = document.getElementById('showTooltips');
        const totalTime = document.getElementById('totalTime');
        const hottestFunction = document.getElementById('hottestFunction');
        const slowFunctions = document.getElementById('slowFunctions');
        const performanceScore = document.getElementById('performanceScore');
        const maxDepthElement = document.getElementById('maxDepth');
        const systemCallRatio = document.getElementById('systemCallRatio');
        const functionDetails = document.getElementById('functionDetails');
        const breadcrumb = document.getElementById('breadcrumb');
        const searchInput = document.getElementById('searchInput');
        const searchClear = document.getElementById('searchClear');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const fitViewBtn = document.getElementById('fitViewBtn');
        const exportBtn = document.getElementById('exportBtn');
        const downloadDataBtn = document.getElementById('downloadDataBtn');
        const flipDataBtn = document.getElementById('flipDataBtn');
        const aggregationResult = document.getElementById('aggregationResult');
        const flameGraphContainer = document.getElementById('flameGraphContainer');
        const emptyState = document.getElementById('emptyState');
        const flameGraph = document.getElementById('flameGraph');

        const statusText = document.getElementById('statusText');
        const tooltip = document.getElementById('tooltip');

        // 示例数据
        const sampleData = {
            "name": "Main Thread",
            "startTime": 0,
            "duration": 33.42,
            "type": "thread",
            "children": [
                {
                    "name": "Update",
                    "startTime": 0,
                    "duration": 15.67,
                    "type": "user",
                    "children": [
                        {
                            "name": "PlayerController.Update",
                            "startTime": 0.1,
                            "duration": 8.23,
                            "type": "user",
                            "children": [
                                {
                                    "name": "Input.GetAxis",
                                    "startTime": 0.2,
                                    "duration": 2.15,
                                    "type": "system"
                                },
                                {
                                    "name": "Transform.Translate",
                                    "startTime": 2.5,
                                    "duration": 3.8,
                                    "type": "system"
                                },
                                {
                                    "name": "Rigidbody.AddForce",
                                    "startTime": 6.8,
                                    "duration": 1.28,
                                    "type": "system"
                                }
                            ]
                        },
                        {
                            "name": "CameraController.LateUpdate",
                            "startTime": 8.5,
                            "duration": 4.12,
                            "type": "user",
                            "children": [
                                {
                                    "name": "Camera.ScreenToWorldPoint",
                                    "startTime": 8.7,
                                    "duration": 1.95,
                                    "type": "system"
                                },
                                {
                                    "name": "Transform.LookAt",
                                    "startTime": 10.8,
                                    "duration": 1.77,
                                    "type": "system"
                                }
                            ]
                        },
                        {
                            "name": "UI.Update",
                            "startTime": 13.0,
                            "duration": 2.67,
                            "type": "user",
                            "children": [
                                {
                                    "name": "Canvas.Rebuild",
                                    "startTime": 13.2,
                                    "duration": 2.47,
                                    "type": "system"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "Render",
                    "startTime": 16.0,
                    "duration": 12.85,
                    "type": "system",
                    "children": [
                        {
                            "name": "Culling",
                            "startTime": 16.2,
                            "duration": 3.45,
                            "type": "system"
                        },
                        {
                            "name": "Shadows",
                            "startTime": 19.8,
                            "duration": 4.23,
                            "type": "system"
                        },
                        {
                            "name": "Opaque",
                            "startTime": 24.2,
                            "duration": 3.67,
                            "type": "system"
                        },
                        {
                            "name": "Transparent",
                            "startTime": 28.0,
                            "duration": 0.85,
                            "type": "system"
                        }
                    ]
                },
                {
                    "name": "Physics.DetectCollisions",
                    "startTime": 29.0,
                    "duration": 4.42,
                    "type": "system",
                    "children": [
                        {
                            "name": "Broadphase",
                            "startTime": 29.2,
                            "duration": 1.23,
                            "type": "system"
                        },
                        {
                            "name": "Narrowphase",
                            "startTime": 30.5,
                            "duration": 2.89,
                            "type": "system"
                        }
                    ]
                }
            ]
        };


        // 解析JSON数据
        function parseJsonData() {
            const jsonText = jsonTextarea.value.trim();
            if (!jsonText) {
                setStatus('请输入JSON数据');
                return;
            }
            
            try {
                const data = JSON.parse(jsonText);
                loadFlameData(data);
            } catch (error) {
                setStatus(`JSON解析错误: ${error.message}`);
            }
        }

        // 标准化数据格式
        function normalizeDataFormat(data) {
            if (!data) return null;
            
            // 检测并转换不同的数据格式
            
            // 格式1: 扁平数组格式 [{name, value, children}, ...]
            if (Array.isArray(data) && data.length > 0) {
                // 如果是数组，取第一个元素作为根节点
                if (data.length === 1) {
                    return normalizeNode(data[0]);
                } else {
                    // 多个根节点，创建一个虚拟根节点
                    return {
                        name: "Root",
                        duration: data.reduce((sum, node) => sum + (node.value || node.duration || node.time || 0), 0),
                        startTime: 0,
                        type: "system",
                        children: data.map(node => normalizeNode(node))
                    };
                }
            }
            
            // 格式2: 单个对象格式
            if (typeof data === 'object') {
                return normalizeNode(data);
            }
            
            return data;
        }
        
        // 标准化单个节点
        function normalizeNode(node) {
            if (!node) return null;
            
            const normalized = {
                name: node.name || node.function || node.method || 'Unknown',
                duration: node.duration || node.value || node.time || node.self || 0,
                startTime: node.startTime || node.start || 0,
                type: node.type || (node.name && node.name.includes('.') ? 'system' : 'user'),
                selfTime: node.selfTime || node.self || 0
            };
            
            // 处理子节点
            if (node.children && Array.isArray(node.children)) {
                normalized.children = node.children.map(child => normalizeNode(child)).filter(child => child !== null);
            } else if (node.calls && Array.isArray(node.calls)) {
                // 支持calls字段作为children的别名
                normalized.children = node.calls.map(child => normalizeNode(child)).filter(child => child !== null);
            }
            
            // 处理特殊格式：如果duration为0但有children，计算children的总和
            if (normalized.duration === 0 && normalized.children && normalized.children.length > 0) {
                normalized.duration = normalized.children.reduce((sum, child) => sum + (child.duration || 0), 0);
            }
            
            return normalized;
        }
        
        // 加载火焰图数据
        function loadFlameData(rawData) {
            // 首先标准化数据格式
            const normalizedData = normalizeDataFormat(rawData);
            if (!normalizedData) {
                setStatus('数据格式无效');
                return;
            }
            
            flameData = normalizedData;
            nodeMap = new Map();
            maxDepth = 0;
            selectedNode = null;
            focusedNode = null;
            highlightedFunction = null;
            
            nodeMap.clear();
            
            // 重新计算startTime确保子节点不超出父节点范围
            function recalculateStartTimes(node, parentStartTime = 0) {
                if (!node) return;
                
                node.startTime = parentStartTime;
                
                if (node.children && node.children.length > 0) {
                    if (node.children.length === 1) {
                        // 单个子节点：确保不超出父节点范围
                        const child = node.children[0];
                        // 如果子节点duration大于等于父节点，则从父节点开始时间开始
                        // 否则居中显示
                        let childStartTime;
                        if (child.duration >= node.duration) {
                            childStartTime = parentStartTime;
                            // 同时调整子节点duration不超过父节点
                            child.duration = Math.min(child.duration, node.duration);
                        } else {
                            childStartTime = parentStartTime + (node.duration - child.duration) / 2;
                        }
                        recalculateStartTimes(child, childStartTime);
                    } else {
                        // 多个子节点：按顺序排列，确保总时长不超过父节点
                        let currentTime = parentStartTime;
                        const totalChildDuration = node.children.reduce((sum, child) => sum + child.duration, 0);
                        
                        if (totalChildDuration > node.duration) {
                            // 如果子节点总时长超过父节点，按比例缩放
                            const scale = node.duration / totalChildDuration;
                            node.children.forEach(child => {
                                child.duration *= scale;
                            });
                        }
                        
                        node.children.forEach(child => {
                            recalculateStartTimes(child, currentTime);
                            currentTime += child.duration;
                        });
                    }
                }
            }
            
            recalculateStartTimes(flameData);
            processFlameData(flameData, nodeMap);
            updateStats(flameData);
            renderFlameGraph();
            updateBreadcrumb();
            
            emptyState.style.display = 'none';
            functionDetails.textContent = '点击火焰图中的函数块查看详细信息';
            setStatus('数据加载完成');
        }

        // 处理火焰图数据
        function processFlameData(node, _nodeMap, depth = 0, parentId = null) {
            // 标准化数据字段：将time/value字段转换为duration
            if (!node.duration) {
                if (node.time !== undefined) {
                    node.duration = node.time;
                } else if (node.value !== undefined) {
                    node.duration = node.value;
                } else {
                    node.duration = 0;
                }
            }
            
            // 处理selfTime字段，如果没有则设为0
            if (node.selfTime === undefined) {
                node.selfTime = 0;
            }
            
            // 设置默认startTime - 居中计算
            if (node.startTime === undefined) {
                if (parentId && _nodeMap.has(parentId)) {
                    const parent = _nodeMap.get(parentId);
                    const parentStart = parent.startTime || 0;
                    const parentDuration = parent.duration || 0;
                    const nodeDuration = node.duration || 0;
                    
                    // 如果子节点duration小于父节点duration，则居中放置
                    if (nodeDuration < parentDuration) {
                        node.startTime = parentStart + (parentDuration - nodeDuration) / 2;
                    } else {
                        node.startTime = parentStart;
                    }
                } else {
                    node.startTime = 0;
                }
            }
            
            // 生成唯一ID
            _key = `${node.name}_${depth}`;
            node.id = _key
            node.depth = depth;
            node.parentId = parentId;
            
            // 存储到映射中
            _nodeMap.set(_key, node);
            
            // 更新最大深度
            maxDepth = Math.max(maxDepth, depth);
            
            // 处理子节点
            if (node.children && node.children.length > 0) {
                if (node.children.length === 1) {
                    // 单个子节点已经在上面的startTime计算中处理了居中逻辑
                    processFlameData(node.children[0], _nodeMap, depth + 1, node.id);
                } else {
                    // 多个子节点按顺序排列，重新计算startTime
                    let childStartTime = node.startTime || 0;
                    node.children.forEach(child => {
                        // 为多子节点情况重新设置startTime
                        child.startTime = childStartTime;
                        processFlameData(child, _nodeMap, depth + 1, node.id);
                        childStartTime += (child.duration || 0);
                    });
                }
            }
        }

        // 更新统计信息
        function updateStats(data) {
            let functionCount = 0;
            let totalDuration = 0;
            let systemCallCount = 0;
            let slowFunctionCount = 0;
            let hottestNode = null;
            let maxDuration = 0;
            
            function analyzeNodes(node) {
                functionCount++;
                totalDuration += node.duration || 0;
                
                // 统计系统调用
                if (node.type === 'system') {
                    systemCallCount++;
                }
                
                // 统计慢函数
                if (node.duration > 10) {
                    slowFunctionCount++;
                }
                
                // 找到最耗时的函数
                if (node.duration > maxDuration) {
                    maxDuration = node.duration;
                    hottestNode = node;
                }
                
                if (node.children) {
                    node.children.forEach(analyzeNodes);
                }
            }
            
            analyzeNodes(data);
            
            // 计算性能评分 (0-100)
            const avgDuration = functionCount > 0 ? totalDuration / functionCount : 0;
            const score = Math.max(0, Math.min(100, 100 - (slowFunctionCount * 10) - (avgDuration * 2)));
            
            // 更新显示
            totalTime.textContent = totalDuration.toFixed(2);
            hottestFunction.textContent = hottestNode ? `${hottestNode.name.substring(0, 12)}...` : '-';
            hottestFunction.title = hottestNode ? `${hottestNode.name} (${hottestNode.duration.toFixed(2)}ms)` : '';
            slowFunctions.textContent = slowFunctionCount;
            performanceScore.textContent = Math.round(score);
            maxDepthElement.textContent = maxDepth + 1;
            systemCallRatio.textContent = functionCount > 0 ? `${Math.round((systemCallCount / functionCount) * 100)}%` : '0%';
        }

        // 渲染火焰图
        function renderFlameGraph() {
            if (!flameData) return;
            
            flameGraph.innerHTML = '';
            
            const containerWidth = flameGraphContainer.clientWidth;
            const rowHeight = parseInt(rowHeightSlider.value);
            const threshold = parseFloat(thresholdSlider.value);
            const minWidth = parseInt(minWidthSlider.value);
            
            // 确定渲染的根节点
            const rootNode = focusedNode || flameData;
            const baseTime = rootNode.startTime || 0;
            const totalTime = rootNode.duration || 1;
            
            function renderNode(node, depth) {
                // 检查过滤条件
                if (node.duration < threshold) return;
                if (!showSystemCalls.checked && node.type === 'system') return;
                if (!showUserCode.checked && node.type === 'user') return;
                
                // 计算位置和大小
                const relativeStart = (node.startTime - baseTime) / totalTime;
                const calculatedWidth = (node.duration / totalTime) * containerWidth * 0.95;
                const width = Math.max(minWidth, calculatedWidth); // 应用最小宽度限制
                const left = relativeStart * containerWidth * 0.95 + 20;
                const top = (depth - (focusedNode ? focusedNode.depth : 0)) * (rowHeight + 1) + 10;
                
                // 如果宽度太小，跳过渲染以提高性能
                if (calculatedWidth < 0.5) return;
                
                // 创建火焰框元素
                const box = document.createElement('div');
                box.className = 'flame-box';
                box.dataset.nodeId = node.id;
                box.style.left = `${left}px`;
                box.style.top = `${top}px`;
                box.style.width = `${width}px`;
                box.style.height = `${rowHeight}px`;
                box.style.backgroundColor = getNodeColor(node);
                
                // 智能文本显示 - 参考 d3-flame-graph 的文本处理
                let displayText = '';
                const nodeName = node.name || 'Unknown';
                if (width > 60) {
                    displayText = nodeName;
                } else if (width > 30) {
                    // 截断长函数名
                    displayText = nodeName.length > 10 ? nodeName.substring(0, 8) + '..' : nodeName;
                } else if (width > 15) {
                    // 只显示首字母
                    displayText = nodeName.charAt(0);
                }
                
                box.textContent = displayText;
                const duration = node.duration || 0;
                box.title = `${nodeName} (${duration.toFixed(2)}ms)`;
                
                // 添加选中和高亮状态
                if (selectedNode && selectedNode.id === node.id) {
                    box.classList.add('selected');
                }
                if (highlightedFunction && nodeName.toLowerCase().includes(highlightedFunction.toLowerCase())) {
                    box.classList.add('highlighted');
                }
                
                // 添加事件监听器
                box.addEventListener('mouseenter', (e) => showTooltip(e, node));
                box.addEventListener('mouseleave', hideTooltip);
                
                flameGraph.appendChild(box);
                
                // 渲染子节点
                if (node.children) {
                    node.children.forEach(child => renderNode(child, depth + 1));
                }
            }
            
            renderNode(rootNode, focusedNode ? focusedNode.depth : 0);
        }

        // 获取节点颜色 - 支持多种配色方案和diff模式
        function getNodeColor(node) {
            // Diff模式优先
            if (isDiffMode && node.diffInfo) {
                const diffType = node.diffInfo.diffType;
                switch (diffType) {
                    case 'removed':
                        return '#8e44ad'; // 删除的函数 - 紫色
                    case 'added':
                        return '#f39c12'; // 新增函数 - 橙色
                    case 'increased':
                        return '#e74c3c'; // 性能下降 - 红色
                    case 'decreased':
                        return '#27ae60'; // 性能提升 - 绿色
                    default:
                        return '#95a5a6'; // 无明显变化 - 灰色
                }
            }
            
            const scheme = colorSchemeSelect.value;
            const hash = hashCode(node.name);
            const hue = Math.abs(hash) % 360;
            
            switch (scheme) {
                case 'performance':
                    // 性能导向配色
                    if (node.duration > 10) {
                        return `hsl(${(hue + 340) % 360}, 85%, 55%)`; // 红色调
                    } else if (node.duration > 1) {
                        return `hsl(${(hue + 30) % 360}, 80%, 60%)`; // 橙黄色调
                    } else if (node.type === 'system') {
                        return `hsl(${(hue + 270) % 360}, 70%, 70%)`; // 紫色调
                    } else {
                        return `hsl(${hue}, 70%, 65%)`;
                    }
                    
                case 'rainbow':
                    // 彩虹色谱
                    return `hsl(${hue}, 80%, 65%)`;
                    
                case 'warm':
                    // 暖色调 (红、橙、黄)
                    const warmHue = (hue % 60) + (node.depth % 3) * 60; // 0-180度
                    return `hsl(${warmHue}, 75%, 65%)`;
                    
                case 'cool':
                    // 冷色调 (蓝、绿、紫)
                    const coolHue = ((hue % 120) + 180) % 360; // 180-300度
                    return `hsl(${coolHue}, 75%, 65%)`;
                    
                case 'monochrome':
                    // 单色调 (不同亮度的蓝色)
                    const lightness = 40 + (hash % 40); // 40-80%
                    return `hsl(210, 60%, ${lightness}%)`;
                    
                default:
                    return `hsl(${hue}, 70%, 65%)`;
            }
        }
        
        // 字符串哈希函数
        function hashCode(str) {
            if (!str || typeof str !== 'string') {
                return 0;
            }
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // 转换为32位整数
            }
            return hash;
        }

        // 显示工具提示
        function showTooltip(event, node) {
            if (!showTooltips.checked) return;
            
            const tooltipTitle = tooltip.querySelector('.tooltip-title');
            const tooltipInfo = tooltip.querySelector('.tooltip-info');
            
            tooltipTitle.textContent = node.name;
            tooltipInfo.innerHTML = `
                <div>持续时间: ${node.duration.toFixed(2)} ms</div>
                <div>开始时间: ${node.startTime.toFixed(2)} ms</div>
                <div>类型: ${node.type}</div>
                <div>深度: ${node.depth}</div>
                ${node.children ? `<div>子函数: ${node.children.length}</div>` : ''}
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = `${event.pageX + 10}px`;
            tooltip.style.top = `${event.pageY + 10}px`;
        }

        // 隐藏工具提示
        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // 更新阈值
        function updateThreshold() {
            thresholdValue.textContent = thresholdSlider.value;
            renderFlameGraph();
        }

        // 更新行高
        function updateRowHeight() {
            rowHeightValue.textContent = rowHeightSlider.value;
            renderFlameGraph();
        }
        
        // 更新最小宽度
        function updateMinWidth() {
            minWidthValue.textContent = minWidthSlider.value;
            renderFlameGraph();
        }

        // 计算差异
        // 生成合并的diff数据
        function generateDiffData(firstData, secondData) {
            if (!firstData || !secondData) return null;
            
            // 创建节点映射
            const firstNodeMap = new Map();
            const secondNodeMap = new Map();
            
            // 构建第一个数据集的节点映射
            function buildNodeMap(node, map, depth = 0) {
                const nodeKey = `${node.name}_${depth}`;
                map.set(nodeKey, {
                    ...node,
                    depth: depth,
                    duration: node.value || node.duration || 0
                });
                
                if (node.children) {
                    node.children.forEach(child => buildNodeMap(child, map, depth + 1));
                }
            }
            
            buildNodeMap(firstData, firstNodeMap);
            buildNodeMap(secondData, secondNodeMap);
            
            // 生成合并的diff数据结构
            function createDiffNode(node, depth = 0) {
                const nodeKey = `${node.name}_${depth}`;
                const firstNode = firstNodeMap.get(nodeKey);
                const secondNode = secondNodeMap.get(nodeKey);
                
                const firstDuration = firstNode ? (firstNode.duration || 0) : 0;
                const secondDuration = secondNode ? (secondNode.duration || 0) : 0;
                
                let change = 0;
                let diffType = 'unchanged';
                
                if (!firstNode && secondNode) {
                    // 新增节点
                    change = 1;
                    diffType = 'added';
                } else if (firstNode && !secondNode) {
                    // 删除节点
                    change = -1;
                    diffType = 'removed';
                } else if (firstNode && secondNode) {
                    // 变化节点
                    change = firstDuration > 0 ? (secondDuration - firstDuration) / firstDuration : 0;
                    if (Math.abs(change) > 0.1) {
                        diffType = change > 0 ? 'increased' : 'decreased';
                    }
                }
                
                const diffNode = {
                    name: node.name,
                    duration: secondDuration || firstDuration,
                    startTime: 0, // 稍后重新计算
                    depth: depth,
                    id: `${node.name}_${depth}_diff`,
                    children: [],
                    diffInfo: {
                        change: change,
                        oldDuration: firstDuration,
                        newDuration: secondDuration,
                        diffType: diffType,
                        exists: !!firstNode,
                        isRemoved: diffType === 'removed'
                    }
                };
                
                // 处理子节点
                const allChildNames = new Set();
                if (firstNode && firstNode.children) {
                    firstNode.children.forEach(child => allChildNames.add(child.name));
                }
                if (secondNode && secondNode.children) {
                    secondNode.children.forEach(child => allChildNames.add(child.name));
                }
                
                allChildNames.forEach(childName => {
                    const firstChild = firstNode && firstNode.children ? 
                        firstNode.children.find(c => c.name === childName) : null;
                    const secondChild = secondNode && secondNode.children ? 
                        secondNode.children.find(c => c.name === childName) : null;
                    
                    const childNode = secondChild || firstChild;
                    if (childNode) {
                        const diffChild = createDiffNode(childNode, depth + 1);
                        diffNode.children.push(diffChild);
                    }
                });
                
                return diffNode;
            }
            
            // 从第二个数据集开始生成（因为它包含了最新的结构）
            return createDiffNode(secondData);
        }
        
        function calculateDiff() {
            if (!flameData || !diffData) return;
            
            // 生成合并的diff数据
            const mergedDiffData = generateDiffData(flameData, diffData);
            if (!mergedDiffData) return;
            
            // 重新计算startTime
            function recalculateStartTimes(node, parentStartTime = 0) {
                if (!node) return;
                
                node.startTime = parentStartTime;
                
                if (node.children && node.children.length > 0) {
                    if (node.children.length === 1) {
                        // 单个子节点：确保不超出父节点范围
                        const child = node.children[0];
                        // 如果子节点duration大于等于父节点，则从父节点开始时间开始
                        // 否则居中显示
                        let childStartTime;
                        if (child.duration >= node.duration) {
                            childStartTime = parentStartTime;
                            // 同时调整子节点duration不超过父节点
                            child.duration = Math.min(child.duration, node.duration);
                        } else {
                            childStartTime = parentStartTime + (node.duration - child.duration) / 2;
                        }
                        recalculateStartTimes(child, childStartTime);
                    } else {
                        // 多个子节点：按顺序排列，确保总时长不超过父节点
                        let currentTime = parentStartTime;
                        const totalChildDuration = node.children.reduce((sum, child) => sum + child.duration, 0);
                        
                        if (totalChildDuration > node.duration) {
                            // 如果子节点总时长超过父节点，按比例缩放
                            const scale = node.duration / totalChildDuration;
                            node.children.forEach(child => {
                                child.duration *= scale;
                            });
                        }
                        
                        node.children.forEach(child => {
                            recalculateStartTimes(child, currentTime);
                            currentTime += child.duration;
                        });
                    }
                }
            }
            
            recalculateStartTimes(mergedDiffData);
            
            // 替换当前的flameData为合并后的diff数据
            flameData = mergedDiffData;
        }   

        // 处理搜索
        function handleSearch() {
            const query = searchInput.value.trim().toLowerCase();
            highlightedFunction = query || null;
            renderFlameGraph();
            
            if (query) {
                setStatus(`搜索: "${query}"`);
            } else {
                setStatus('就绪');
            }
        }

        // 清除搜索
        function clearSearch() {
            searchInput.value = '';
            highlightedFunction = null;
            renderFlameGraph();
            setStatus('已清除搜索');
        }

        // 选择节点
        function selectNode(node) {
            selectedNode = node;
            updateFunctionDetails(node);
            renderFlameGraph();
        }

        // 取消选择节点
        function deselectNode() {
            selectedNode = null;
            functionDetails.textContent = '点击火焰图中的函数块查看详细信息';
            renderFlameGraph();
        }

        // 更新函数详情
        function updateFunctionDetails(node) {
            if (!node) {
                functionDetails.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">点击火焰图中的函数块查看详细信息</div>';
                return;
            }
            
            // 计算性能等级
            const getPerformanceLevel = (duration) => {
                if (duration > 10) return { level: 'danger', text: '性能瓶颈' };
                if (duration > 1) return { level: 'warning', text: '需要关注' };
                return { level: 'highlight', text: '性能良好' };
            };
            
            const performance = getPerformanceLevel(node.duration);
            const endTime = node.startTime + node.duration;
            const childCount = node.children ? node.children.length : 0;
            const totalChildTime = node.children ? node.children.reduce((sum, child) => sum + child.duration, 0) : 0;
            const selfTime = node.duration - totalChildTime;
            const selfTimePercent = node.duration > 0 ? (selfTime / node.duration * 100) : 0;
            
            // 计算性能条的宽度 (基于相对耗时)
            const maxTime = flameData ? flameData.duration : node.duration;
            const performanceWidth = Math.min(100, (node.duration / maxTime) * 100);
            
            functionDetails.innerHTML = `
                <div class="detail-header">
                    📊 ${node.name}
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">执行时间:</span>
                    <span class="detail-value ${performance.level}">${node.duration.toFixed(2)} ms</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">性能状态:</span>
                    <span class="detail-value ${performance.level}">${performance.text}</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">时间范围:</span>
                    <span class="detail-value">${node.startTime.toFixed(2)} - ${endTime.toFixed(2)} ms</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">自身耗时:</span>
                    <span class="detail-value">${selfTime.toFixed(2)} ms (${selfTimePercent.toFixed(1)}%)</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">调用深度:</span>
                    <span class="detail-value">第 ${node.depth + 1} 层</span>
                </div>
                
                <div class="detail-row">
                    <span class="detail-label">函数类型:</span>
                    <span class="detail-value">${node.type === 'system' ? '🔧 系统调用' : '👤 用户代码'}</span>
                </div>
                
                <div class="detail-row">
                     <span class="detail-label">子函数:</span>
                     <span class="detail-value">${childCount} 个</span>
                 </div>
                 
                 ${node.diffInfo && isDiffMode ? `
                 <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #444;">
                     <div class="detail-header" style="font-size: 13px; margin-bottom: 8px;">📊 Diff对比</div>
                     
                     <div class="detail-row">
                         <span class="detail-label">变化:</span>
                         <span class="detail-value ${node.diffInfo.change > 0.1 ? 'danger' : node.diffInfo.change < -0.1 ? 'highlight' : ''}">
                             ${node.diffInfo.change > 0 ? '+' : ''}${(node.diffInfo.change * 100).toFixed(1)}%
                         </span>
                     </div>
                     
                     <div class="detail-row">
                         <span class="detail-label">原始时间:</span>
                         <span class="detail-value">${node.diffInfo.oldDuration.toFixed(2)} ms</span>
                     </div>
                     
                     <div class="detail-row">
                         <span class="detail-label">当前时间:</span>
                         <span class="detail-value">${node.diffInfo.newDuration.toFixed(2)} ms</span>
                     </div>
                     
                     <div class="detail-row">
                         <span class="detail-label">状态:</span>
                         <span class="detail-value">
                             ${node.diffInfo.diffType === 'removed' ? '🟣 删除函数' :
                               node.diffInfo.diffType === 'added' ? '🟠 新增函数' :
                               node.diffInfo.diffType === 'increased' ? '🔴 性能下降' : 
                               node.diffInfo.diffType === 'decreased' ? '🟢 性能提升' : '⚪ 无明显变化'}
                         </span>
                     </div>
                 </div>
                 ` : ''}
                 
                 <div style="margin-top: 12px;">
                     <div class="detail-label">相对性能:</div>
                     <div class="performance-bar">
                         <div class="performance-fill" style="width: ${performanceWidth}%"></div>
                     </div>
                 </div>
            `;
        }

        // 聚焦到节点
        function focusNode(node) {
            focusedNode = node;
            selectedNode = null;
            renderFlameGraph();
            updateBreadcrumb();
            setStatus(`已聚焦到: ${node.name}`);
        }

        // 重置聚焦
        function resetFocus() {
            focusedNode = null;
            selectedNode = null;
            renderFlameGraph();
            updateBreadcrumb();
            setStatus('已重置聚焦');
        }

        // 更新面包屑导航
        function updateBreadcrumb() {
            breadcrumb.innerHTML = '';
            
            // 构建路径
            const path = [];
            let current = focusedNode;
            
            while (current) {
                path.unshift(current);
                current = current.parentId ? nodeMap.get(current.parentId) : null;
            }
            
            // 添加根节点
            if (!focusedNode) {
                path.unshift({ id: 'root', name: '根节点' });
            } else {
                path.unshift({ id: 'root', name: '根节点' });
            }
            
            // 渲染面包屑
            path.forEach((node, index) => {
                if (index > 0) {
                    const separator = document.createElement('span');
                    separator.className = 'breadcrumb-separator';
                    separator.textContent = '>';
                    breadcrumb.appendChild(separator);
                }
                
                const item = document.createElement('a');
                item.className = 'breadcrumb-item';
                item.href = '#';
                item.textContent = node.name;
                item.dataset.nodeId = node.id;
                breadcrumb.appendChild(item);
            });
        }

        // 处理面包屑点击
        function handleBreadcrumbClick(event) {
            event.preventDefault();
            
            if (event.target.classList.contains('breadcrumb-item')) {
                const nodeId = event.target.dataset.nodeId;
                
                if (nodeId === 'root') {
                    resetFocus();
                } else {
                    const node = nodeMap.get(nodeId);
                    if (node) {
                        focusNode(node);
                    }
                }
            }
        }

        // 重置视图变换
        function resetViewTransform() {
            panOffset = { x: 0, y: 0 };
            flameGraph.style.transform = 'translate(0px, 0px)';
        }

        // 处理鼠标按下
        function handleMouseDown(event) {
            mouseDownPos = { x: event.clientX, y: event.clientY };
            mouseDownTime = Date.now();
            isDragging = false;
        }

        // 处理鼠标移动
        function handleMouseMove(event) {
            if (mouseDownTime > 0) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 如果移动距离超过阈值，认为是拖拽
                if (distance > 5) {
                    isDragging = true;
                    lastMousePos = { x: event.clientX, y: event.clientY };
                    flameGraphContainer.style.cursor = 'grabbing';
                    
                    // 如果拖拽开始于火焰框，则隐藏工具提示
                    hideTooltip();
                }
            }
        }

        // 处理鼠标松开
        function handleMouseUp(event) {
            // 计算鼠标按下的持续时间
            const clickDuration = Date.now() - mouseDownTime;
            
            // 如果没有拖拽，且点击时间短，则认为是点击
            if (!isDragging && clickDuration < 200) {
                // 如果点击的是火焰框
                if (event.target.classList.contains('flame-box')) {
                    const nodeId = event.target.dataset.nodeId;
                    const node = nodeMap.get(nodeId);
                    
                    if (node) {
                        // 区分单击和双击 - 增加双击检测时间以提高响应性
                        const now = Date.now();
                        console.log('点击时间间隔:', now - lastClickTime, 'ms', '当前选中节点:', selectedNode ? selectedNode.name : 'none', '点击节点:', node.name);
                        
                        if (now - lastClickTime < 400 && selectedNode && selectedNode.id === node.id) {
                            // 双击 - 聚焦到节点，添加视觉反馈
                            console.log('触发双击事件:', node.name);
                            event.target.style.transform = 'scale(1.05)';
                            setTimeout(() => {
                                event.target.style.transform = '';
                            }, 150);
                            focusNode(node);
                            setStatus(`双击聚焦: ${node.name}`);
                        } else {
                            // 单击 - 选择节点
                            console.log('触发单击事件:', node.name);
                            selectNode(node);
                            setStatus(`已选择: ${node.name}`);
                        }
                        lastClickTime = now;
                    }
                } else {
                    // 点击空白区域取消选择
                    if (selectedNode) {
                        deselectNode();
                        setStatus('已取消选择');
                    }
                }
            }
            
            // 重置状态
            isDragging = false;
            mouseDownTime = 0;
            flameGraphContainer.style.cursor = 'default';
        }

        // 处理鼠标离开
        function handleMouseLeave() {
            isDragging = false;
            mouseDownTime = 0;
            hideTooltip();
            flameGraphContainer.style.cursor = 'default';
        }

        // 鼠标滚轮垂直滚动
        function handleWheel(event) {
            event.preventDefault();
            
            // 垂直滚动
            const scrollAmount = event.deltaY;
            panOffset.y -= scrollAmount * 0.5;
            
            flameGraph.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px)`;
        }

        // 适应视图
        function fitFlameGraphToView() {
            if (!flameData) return;
            
            // 重置水平位置居中，保持垂直位置不变
            panOffset.x = 0;
            
            flameGraph.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px)`;
        }

        // 重置视图
        function resetView() {
            // 重置所有状态
            panOffset = { x: 0, y: 0 };
            searchInput.value = '';
            highlightedFunction = null;
            selectedNode = null;
            focusedNode = null;
            functionDetails.textContent = '点击火焰图中的函数块查看详细信息';
            
            renderFlameGraph();
            updateBreadcrumb();
            setStatus('已重置视图');
        }

        // 导出图片
        function exportImage() {
            setStatus('正在准备导出...');
            
            try {
                // 使用html2canvas库导出（假设已加载）
                // 注意：实际实现需要加载html2canvas库
                alert('此功能需要html2canvas库支持，请在实际应用中集成');
                setStatus('导出功能在此演示中不可用');
                
                // html2canvas实现示例：
                /*
                html2canvas(flameGraph).then(canvas => {
                    const link = document.createElement('a');
                    link.download = 'flame-graph.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    setStatus('图片已导出');
                });
                */
            } catch (error) {
                console.error('导出图片出错:', error);
                setStatus(`导出错误: ${error.message}`);
            }
        }

        // 下载当前数据
        function downloadCurrentData() {
            if (!flameData) {
                setStatus('没有可下载的数据');
                return;
            }
            
            try {
                setStatus('正在准备下载...');
                
                // 创建下载数据
                const dataToDownload = {
                    metadata: {
                        exportTime: new Date().toISOString(),
                        version: '1.0',
                        description: '火焰图数据导出'
                    },
                    data: flameData
                };
                
                // 转换为JSON字符串
                const jsonString = JSON.stringify(dataToDownload, null, 2);
                
                // 创建Blob对象
                const blob = new Blob([jsonString], { type: 'application/json' });
                
                // 创建下载链接
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                
                // 生成文件名
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.download = `flame-graph-data-${timestamp}.json`;
                
                // 触发下载
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 清理URL对象
                URL.revokeObjectURL(url);
                
                setStatus('数据已下载');
                
            } catch (error) {
                console.error('下载数据出错:', error);
                setStatus(`下载错误: ${error.message}`);
            }
        }

        // 设置状态消息
        function setStatus(message) {
            statusText.textContent = message;
        }

        // 添加数据到文件列表
        function addDataToList(data, name) {
            const dataItem = {
                id: Date.now() + Math.random(),
                name: name,
                data: JSON.parse(JSON.stringify(data)),
                timestamp: new Date().toLocaleString()
            };
            
            dataFileList.push(dataItem);
            updateDataSelectors();
            updateDataFileListDisplay();
            setStatus(`已添加数据: ${name}`);
        }
        
        // 更新数据选择器
        function updateDataSelectors() {
            // 清空选择器
            dataFirstSelect.innerHTML = '<option value="">请选择数据...</option>';
            dataSecondSelect.innerHTML = '<option value="">无对比数据</option>';
            
            // 添加数据选项
            dataFileList.forEach((item, index) => {
                const option1 = document.createElement('option');
                option1.value = index;
                option1.textContent = item.name;
                dataFirstSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = item.name;
                dataSecondSelect.appendChild(option2);
            });
            
            // 如果是第一个数据，自动选中
            if (dataFileList.length === 1) {
                dataFirstSelect.value = '0';
                handleDataFirstChange();
            }
        }
        
        // 更新数据文件列表显示
        function updateDataFileListDisplay() {
            if (dataFileList.length === 0) {
                dataFileListElement.innerHTML = '<div style="padding: 10px; text-align: center; color: #666; font-size: 12px;">暂无数据文件</div>';
                return;
            }
            
            let html = '';
            dataFileList.forEach((item, index) => {
                const isFirst = index == currentDataIndex;
                const isSecond = index == diffDataIndex;
                const statusText = isFirst ? ' [First]' : (isSecond ? ' [Second]' : '');
                const statusColor = isFirst ? '#4a7c59' : (isSecond ? '#7c4a59' : '#666');
                
                html += `
                    <div class="data-file-item" style="padding: 8px; border-bottom: 1px solid #333; font-size: 12px; color: ${statusColor};">
                        <div style="font-weight: bold;">${item.name}${statusText}</div>
                        <div style="color: #888; font-size: 10px;">${item.timestamp}</div>
                        <button onclick="removeDataItem(${index})" style="float: right; margin-top: -20px; background: #444; border: none; color: #ccc; padding: 2px 6px; border-radius: 2px; cursor: pointer; font-size: 10px;">删除</button>
                    </div>
                `;
            });
            
            dataFileListElement.innerHTML = html;
        }
        
        // 删除数据项
        function removeDataItem(index) {
            dataFileList.splice(index, 1);
            
            // 更新索引
            if (currentDataIndex === index) {
                currentDataIndex = -1;
                flameData = null;
            } else if (currentDataIndex > index) {
                currentDataIndex--;
            }
            
            if (diffDataIndex === index) {
                diffDataIndex = -1;
                diffData = null;
                isDiffMode = false;
            } else if (diffDataIndex > index) {
                diffDataIndex--;
            }
            
            updateDataSelectors();
            updateDataFileListDisplay();
            
            // 重新渲染
            if (currentDataIndex >= 0 && dataFileList[currentDataIndex]) {
                loadFlameData(dataFileList[currentDataIndex].data);
            } else {
                clearFlameGraph();
            }
        }
        
        // 处理First数据选择变化
        function handleDataFirstChange() {
            const selectedIndex = parseInt(dataFirstSelect.value);
            if (selectedIndex >= 0 && dataFileList[selectedIndex]) {
                currentDataIndex = selectedIndex;
                loadFlameData(dataFileList[selectedIndex].data);
                updateDataFileListDisplay();
                setStatus(`已切换到: ${dataFileList[selectedIndex].name}`);
            }
        }
        
        // 处理Second数据选择变化
        function handleDataSecondChange() {
            const selectedIndex = parseInt(dataSecondSelect.value);
            
            if (selectedIndex >= 0 && dataFileList[selectedIndex]) {
                diffDataIndex = selectedIndex;
                diffData = dataFileList[selectedIndex].data;
                isDiffMode = true;
                diffLegend.style.display = 'block';
                
                if (flameData) {
                    diffNodeMap.clear();
                    processFlameData(diffData, diffNodeMap);
                    calculateDiff();
                    renderFlameGraph();
                }
                
                updateDataFileListDisplay();
                setStatus(`已启用对比模式: ${dataFileList[selectedIndex].name}`);
            } else {
                diffDataIndex = -1;
                diffData = null;
                isDiffMode = false;
                diffLegend.style.display = 'none';
                
                if (flameData) {
                    renderFlameGraph();
                }
                
                updateDataFileListDisplay();
                setStatus('已关闭对比模式');
            }
        }
        
        // 清空火焰图
        function clearFlameGraph() {
            flameData = null;
            nodeMap.clear();
            selectedNode = null;
            focusedNode = null;
            svg.innerHTML = '';
            functionDetails.innerHTML = '<div class="no-selection">点击节点查看详细信息</div>';
            breadcrumb.innerHTML = '';
            setStatus('已清空火焰图');
        }
        
        // 加载示例数据
        function loadSampleData() {
            addDataToList(sampleData, '示例数据');
        }

        // 处理文件上传
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                try {
                    const data = parseFlameData(content);
                    if (data) {
                        addDataToList(data, file.name);
                        setStatus(`已加载文件: ${file.name}`);
                    } else {
                        setStatus(`文件格式不支持: ${file.name}`);
                    }
                } catch (error) {
                    setStatus(`文件解析错误: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }

        // 事件监听器
        function init() {
            // 文件输入事件
            fileInput.addEventListener('change', handleFileUpload);
            parseJsonBtn.addEventListener('click', handleJsonPaste);
            loadSampleBtn.addEventListener('click', loadSampleData);

            // 数据选择器事件
            dataFirstSelect.addEventListener('change', handleDataFirstChange);
            dataSecondSelect.addEventListener('change', handleDataSecondChange);
            
            // 设置控件事件
            thresholdSlider.addEventListener('input', updateThreshold);
            rowHeightSlider.addEventListener('input', updateRowHeight);
            minWidthSlider.addEventListener('input', updateMinWidth);
            colorSchemeSelect.addEventListener('change', renderFlameGraph);
            
            showSystemCalls.addEventListener('change', renderFlameGraph);
            showUserCode.addEventListener('change', renderFlameGraph);
            showTooltips.addEventListener('change', () => {
                if (!showTooltips.checked) hideTooltip();
            });
            
            // 搜索事件
            searchInput.addEventListener('input', handleSearch);
            searchClear.addEventListener('click', clearSearch);
            
            // 工具栏按钮事件
            resetViewBtn.addEventListener('click', resetView);
            fitViewBtn.addEventListener('click', fitFlameGraphToView);
            exportBtn.addEventListener('click', exportImage);
            downloadDataBtn.addEventListener('click', downloadCurrentData);
            
            // 数据聚合功能事件
            flipDataBtn.addEventListener('click', handleReverseDataAggregation);
            

            
            // 火焰图容器事件
            flameGraphContainer.addEventListener('mousedown', handleMouseDown);
            flameGraphContainer.addEventListener('mousemove', handleMouseMove);
            flameGraphContainer.addEventListener('mouseup', handleMouseUp);
            flameGraphContainer.addEventListener('mouseleave', handleMouseLeave);
            flameGraphContainer.addEventListener('wheel', handleWheel);
            
            // 面包屑导航事件
            breadcrumb.addEventListener('click', handleBreadcrumbClick);
            
            // 窗口大小变化事件
            window.addEventListener('resize', () => {
                if (flameData) {
                    renderFlameGraph();
                }
            });
        }
        
        
        // 解析火焰图数据（支持多种格式）
        function parseFlameData(content) {
            if (!content || typeof content !== 'string') {
                throw new Error('内容为空或格式无效');
            }
            
            const trimmedContent = content.trim();
            
            // 尝试解析JSON格式
            try {
                return JSON.parse(trimmedContent);
            } catch (jsonError) {
                // JSON解析失败，尝试其他格式
            }
            
            // 尝试解析CSV格式（简单的调用栈格式）
            if (trimmedContent.includes(',') || trimmedContent.includes(';')) {
                try {
                    return parseCSVFormat(trimmedContent);
                } catch (csvError) {
                    // CSV解析失败
                }
            }
            
            // 尝试解析调用栈文本格式
            if (trimmedContent.includes('\n') && (trimmedContent.includes('ms') || trimmedContent.includes('μs') || trimmedContent.includes('ns'))) {
                try {
                    return parseStackTraceFormat(trimmedContent);
                } catch (stackError) {
                    // 调用栈解析失败
                }
            }
            
            // 尝试修复常见的JSON格式问题
            try {
                return parseFlexibleJSON(trimmedContent);
            } catch (flexError) {
                throw new Error(`不支持的数据格式。支持的格式：JSON、CSV、调用栈文本`);
            }
        }
        
        // 解析CSV格式
        function parseCSVFormat(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length === 0) throw new Error('CSV内容为空');
            
            const headers = lines[0].split(',').map(h => h.trim());
            const nameIndex = headers.findIndex(h => h.toLowerCase().includes('name') || h.toLowerCase().includes('function'));
            const durationIndex = headers.findIndex(h => h.toLowerCase().includes('duration') || h.toLowerCase().includes('time') || h.toLowerCase().includes('value'));
            
            if (nameIndex === -1) throw new Error('CSV中未找到函数名列');
            if (durationIndex === -1) throw new Error('CSV中未找到时间/值列');
            
            const nodes = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length > Math.max(nameIndex, durationIndex)) {
                    nodes.push({
                        name: values[nameIndex],
                        duration: parseFloat(values[durationIndex]) || 0,
                        type: 'user'
                    });
                }
            }
            
            return {
                name: 'Root',
                duration: nodes.reduce((sum, node) => sum + node.duration, 0),
                children: nodes
            };
        }
        
        // 解析调用栈文本格式
        function parseStackTraceFormat(content) {
            const lines = content.split('\n').filter(line => line.trim());
            const root = { name: 'Root', duration: 0, children: [] };
            
            lines.forEach(line => {
                const match = line.match(/(.+?)\s+(\d+(?:\.\d+)?)\s*(ms|μs|ns|s)/i);
                if (match) {
                    const name = match[1].trim();
                    let duration = parseFloat(match[2]);
                    const unit = match[3].toLowerCase();
                    
                    // 转换为毫秒
                    if (unit === 's') duration *= 1000;
                    else if (unit === 'μs') duration /= 1000;
                    else if (unit === 'ns') duration /= 1000000;
                    
                    root.children.push({
                        name: name,
                        duration: duration,
                        type: name.includes('.') ? 'system' : 'user'
                    });
                    root.duration += duration;
                }
            });
            
            return root;
        }
        
        // 解析灵活的JSON格式（修复常见问题）
        function parseFlexibleJSON(content) {
            // 尝试修复常见的JSON格式问题
            let fixedContent = content
                .replace(/'/g, '"')  // 单引号转双引号
                .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')  // 属性名加引号
                .replace(/,\s*}/g, '}')  // 移除尾随逗号
                .replace(/,\s*]/g, ']'); // 移除数组尾随逗号
            
            return JSON.parse(fixedContent);
        }
        
        // 处理JSON粘贴
        function handleJsonPaste() {
            const jsonText = jsonTextarea.value.trim();
            if (jsonText) {
                try {
                    const data = parseFlameData(jsonText);
                    const timestamp = new Date().toLocaleTimeString();
                    addDataToList(data, `粘贴数据_${timestamp}`);
                    // 清空文本框
                    jsonTextarea.value = '';
                    setStatus('数据解析成功');
                } catch (error) {
                    setStatus(`数据解析错误: ${error.message}`);
                }
            } else {
                setStatus('请输入数据');
            }
        }

        // 数据倒转功能
        function handleReverseDataAggregation() {
            if (!flameData) {
                setStatus('请先加载数据');
                return;
            }
            
            const aggregationInfo = document.querySelector('.aggregation-info');
            
            try {
                const reversedData = reverseCallStack(flameData);
                const resultMessage = '已完成数据倒转';
                
                // 更新数据并重新渲染
                const timestamp = new Date().toLocaleTimeString();
                addDataToList(reversedData, `倒转数据_${timestamp}`);
                
                // 显示结果信息
                aggregationResult.textContent = resultMessage;
                aggregationInfo.style.display = 'block';
                
                setStatus(resultMessage);
                
                // 3秒后隐藏结果信息
                setTimeout(() => {
                    aggregationInfo.style.display = 'none';
                }, 3000);
                
            } catch (error) {
                setStatus(`聚合操作失败: ${error.message}`);
                aggregationResult.textContent = `错误: ${error.message}`;
                aggregationInfo.style.display = 'block';
            }
        }
        
        // 调用栈倒转功能
        function reverseCallStack(data) {
            const clonedData = JSON.parse(JSON.stringify(data));
            
            // 首先建立节点映射，用于快速查找原始节点信息
            const nodeMap = new Map();
            
            function buildNodeMap(node, path = []) {
                const nodePath = [...path, node.name];
                const nodeKey = nodePath.join('>');
                nodeMap.set(nodeKey, {
                    ...node,
                    path: nodePath
                });
                
                if (node.children) {
                    node.children.forEach(child => buildNodeMap(child, nodePath));
                }
            }
            
            buildNodeMap(clonedData);
            
            // 收集所有从根到叶子的完整路径，包括非叶子节点的self时间路径
            function collectAllPaths(node, currentPath = []) {
                const newPath = [...currentPath, {
                    name: node.name,
                    duration: node.duration || 0,
                    type: node.type || 'user',
                    startTime: node.startTime || 0,
                    originalNode: node
                }];
                
                let allPaths = [];
                
                if (!node.children || node.children.length === 0) {
                    // 叶子节点，返回完整路径
                    allPaths.push(newPath);
                } else {
                    // 非叶子节点：先收集子路径
                    node.children.forEach(child => {
                        const childPaths = collectAllPaths(child, newPath);
                        allPaths = allPaths.concat(childPaths);
                    });
                    
                    // 计算当前节点的self时间
                    const childrenTotalTime = node.children.reduce((sum, child) => {
                        return sum + (child.duration || 0);
                    }, 0);
                    const selfTime = Math.max(0, (node.duration || 0) - childrenTotalTime);
                    
                    // 如果self时间大于0，为当前节点创建一个独立的路径（只包含到当前节点的路径，时间为self时间）
                    if (selfTime > 0) {
                        // 创建一个新的路径，最后一个节点的duration设为selfTime
                        const selfPath = newPath.map((pathNode, index) => {
                            if (index === newPath.length - 1) {
                                // 最后一个节点（当前节点）的duration设为selfTime
                                return {
                                    ...pathNode,
                                    duration: selfTime,
                                    isSelfTime: true
                                };
                            }
                            return pathNode;
                        });
                        allPaths.push(selfPath);
                        console.log('添加self时间路径:', selfPath.map(n => n.name).join(' -> '), '时间:', selfTime);
                    }
                }
                
                return allPaths;
            }
            
            // 计算每个节点的self时间
            function calculateSelfTimes(path) {
                const pathWithSelfTime = [];
                
                for (let i = 0; i < path.length; i++) {
                    const pathNode = path[i];
                    const originalNode = pathNode.originalNode;
                    let selfTime;
                    
                    // 如果是self时间节点，直接使用其duration
                    if (pathNode.isSelfTime) {
                        selfTime = pathNode.duration;
                    } else {
                        // 计算原始节点的所有直接子节点的总时间
                        selfTime = originalNode.duration || 0;
                        if (originalNode.children && originalNode.children.length > 0) {
                            const childrenTotalTime = originalNode.children.reduce((sum, child) => {
                                return sum + (child.duration || 0);
                            }, 0);
                            selfTime = Math.max(0, selfTime - childrenTotalTime);
                        }
                    }
                    
                    pathWithSelfTime.push({
                        name: pathNode.name,
                        duration: pathNode.duration,
                        type: pathNode.type,
                        selfTime: selfTime
                    });
                }
                
                return pathWithSelfTime;
            }
            
            const allPaths = collectAllPaths(clonedData);
            
            // 添加日志分析
            console.log('=== 倒转数据分析 ===');
            console.log('原始数据根节点:', clonedData.name);
            console.log('收集到的路径数量:', allPaths.length);
            console.log('前3条路径示例:');
            allPaths.slice(0, 3).forEach((path, index) => {
                console.log(`路径${index + 1}:`, path.map(node => node.name).join(' -> '));
            });
            
            // 为每个路径创建倒转后的树结构
            const reversedTrees = allPaths.map(path => {
                const pathWithSelfTime = calculateSelfTimes(path);
                // 倒转路径：叶子节点变成根节点
                const reversedPath = [...pathWithSelfTime].reverse();
                
                console.log('倒转前路径:', pathWithSelfTime.map(node => node.name).join(' -> '));
                console.log('倒转后路径:', reversedPath.map(node => node.name).join(' -> '));
                
                let currentNode = null;
                
                // 从叶子节点开始构建倒转的树
                let rootNode = null;
                reversedPath.forEach((pathNode, index) => {
                    const newNode = {
                        name: pathNode.name,
                        duration: pathNode.duration, // 使用原始duration，不是selfTime
                        startTime: 0,
                        type: pathNode.type,
                        children: [],
                        selfTime: pathNode.selfTime // 保留selfTime信息用于显示
                    };
                    
                    if (index === 0) {
                        // 第一个节点是新的根节点（原来的叶子节点）
                        rootNode = newNode;
                        currentNode = newNode;
                    } else {
                        // 后续节点作为前一个节点的子节点
                        currentNode.children = [newNode];
                        currentNode = newNode;
                    }
                });
                
                console.log('构建的树根节点:', rootNode ? rootNode.name : 'null', '时间:', rootNode ? rootNode.duration : 'null');
                return rootNode;
            });
            
            console.log('倒转后的树根节点:', reversedTrees.map(tree => tree ? tree.name : 'null'));
            
            // 合并相邻的同名节点
            function mergeAdjacentNodes(children) {
                if (!children || children.length <= 1) {
                    return children;
                }
                
                const merged = [];
                let i = 0;
                
                while (i < children.length) {
                    let currentNode = { ...children[i], children: [...children[i].children] };
                    let j = i + 1;
                    
                    // 查找相邻的同名节点
                    while (j < children.length && children[j].name === currentNode.name) {
                        // 合并duration
                        currentNode.duration += children[j].duration;
                        
                        // 合并子节点
                        const childrenMap = new Map();
                        
                        // 添加当前节点的子节点
                        currentNode.children.forEach(child => {
                            childrenMap.set(child.name, { ...child, children: [...child.children] });
                        });
                        
                        // 合并下一个节点的子节点
                        children[j].children.forEach(child => {
                            if (childrenMap.has(child.name)) {
                                const existingChild = childrenMap.get(child.name);
                                existingChild.duration += child.duration;
                                existingChild.children = existingChild.children.concat(child.children);
                            } else {
                                childrenMap.set(child.name, { ...child, children: [...child.children] });
                            }
                        });
                        
                        currentNode.children = Array.from(childrenMap.values());
                        j++;
                    }
                    
                    // 递归处理子节点
                    currentNode.children = mergeAdjacentNodes(currentNode.children);
                    
                    // 重新计算子节点的startTime
                    let currentTime = 0;
                    currentNode.children.forEach(child => {
                        child.startTime = currentTime;
                        currentTime += child.duration;
                    });
                    
                    merged.push(currentNode);
                    i = j;
                }
                
                return merged;
            }
            
            // 深度合并相同名称的根节点和子树
            function mergeNodes(node1, node2) {
                // 合并两个节点的duration
                node1.duration += node2.duration;
                
                // 合并子节点
                const childrenMap = new Map();
                
                // 先添加node1的子节点
                node1.children.forEach(child => {
                    childrenMap.set(child.name, { ...child, children: [...child.children] });
                });
                
                // 合并node2的子节点
                node2.children.forEach(child => {
                    if (childrenMap.has(child.name)) {
                        // 递归合并相同名称的子节点
                        mergeNodes(childrenMap.get(child.name), child);
                    } else {
                        childrenMap.set(child.name, { ...child, children: [...child.children] });
                    }
                });
                
                node1.children = Array.from(childrenMap.values());
                
                // 合并相邻的同名子节点
                node1.children = mergeAdjacentNodes(node1.children);
                
                // 重新计算子节点的startTime
                let currentTime = 0;
                node1.children.forEach(child => {
                    child.startTime = currentTime;
                    currentTime += child.duration;
                });
            }
            
            const mergedRoots = new Map();
            
            reversedTrees.forEach(tree => {
                if (tree) {
                    const rootName = tree.name;
                    if (mergedRoots.has(rootName)) {
                        const existingRoot = mergedRoots.get(rootName);
                        mergeNodes(existingRoot, tree);
                    } else {
                        mergedRoots.set(rootName, { ...tree, children: [...tree.children] });
                    }
                }
            });
            
            console.log('合并后的根节点名称:', Array.from(mergedRoots.keys()));
            
            // 直接返回合并后的根节点数组，不再创建新的包装根节点
            let newRootChildren = Array.from(mergedRoots.values());
            
            // 对根节点也应用相邻节点合并
            newRootChildren = mergeAdjacentNodes(newRootChildren);
            
            let currentTime = 0;
            newRootChildren.forEach(child => {
                child.startTime = currentTime;
                currentTime += child.duration;
            });
            
            console.log('最终返回的根节点数量:', newRootChildren.length);
            console.log('最终根节点名称:', newRootChildren.map(child => child.name));
            
            // 如果只有一个根节点，直接返回它；如果有多个，创建一个虚拟根节点
            if (newRootChildren.length === 1) {
                console.log('返回单个根节点:', newRootChildren[0].name);
                return newRootChildren[0];
            } else {
                console.log('返回多个根节点，创建虚拟根节点');
                return {
                    name: '倒转调用栈 (多个根节点)',
                    duration: newRootChildren.reduce((sum, child) => sum + child.duration, 0),
                    startTime: 0,
                    type: 'root',
                    children: newRootChildren
                };
            }
        }
        

        
        // 初始化
        init();
        
        // 延迟加载示例数据（模拟）
        // setTimeout(loadSampleData, 500);
    </script>
</body>
</html>